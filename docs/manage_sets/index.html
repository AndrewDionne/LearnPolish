<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- 1) Dual-host <base> (GitHub Pages vs Flask) -->
  <script>
    (function () {
      // If hosted at andrewdionne.github.io/LearnPolish/ use that as base.
      // Otherwise (Flask/local), use root "/".
      var isGH = /\.github\.io$/i.test(location.hostname);
      var baseHref = isGH ? '/LearnPolish/' : '/';
      document.write('<base href="' + baseHref + '">');
    })();
  </script>

  <!-- 2) Fonts (optional) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <!-- keep or adjust families as you like -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@600;700&family=Manrope:wght@700;800&family=Source+Serif+4:opsz,wght@8..60,400;8..60,600&display=swap" rel="stylesheet">

  <!-- 3) Styles (now safe to load relatively thanks to <base>) -->
  <link rel="stylesheet" href="static/app.css?v=5">
  <title>Library ‚Ä¢ Path to POLISH</title>

</head>

<body
  data-header="Path to Polish"                       
  data-note-lead="Welcome to the library"            
  data-note-tail="Search the collections to find one for you, or create your own!"  
  data-note-no-sep 
  data-note-tight                                 
  style="
    /* Page-level typographic tweaks (override tokens from app.css) */
    --logo-size: 48px;
    --banner-font: 'Manrope', -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial;
    --banner-weight: 800;
    --banner-track: .01em;
    --banner-case: none;
    --banner-size: 28px;       /* iPhone size */
    --banner-size-lg: 36px;    /* desktop size */
    --banner-nudge-x: 10px;

    --note-lead-font: 'Inter', ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    --note-lead-size: 18px;
    --note-lead-weight: 700;
    --note-lead-track: .02em;
    --note-lead-case: none;
    --note-lead-color: var(--text);

    --note-font: 'Source Serif 4', ui-serif, Georgia, 'Times New Roman', serif;
    --note-weight: 400;
  ">
  <!-- Header (brand mark + banner left, auth buttons right) -->
  <header class="topbar no-nav">
    <div class="row container">
      <div class="header-left">
        <a class="brand" href="index.html" aria-label="Path to Polish ‚Äî Home">
          <svg class="brand-mark" aria-hidden="true" focusable="false">
            <use href="static/brand.svg#ptp-mark"></use>
          </svg>
          <span id="headerBanner" class="header-banner"></span>
        </a>
      </div>
      <nav class="head-actions">
        <a href="profile.html"  id="profileBtn">Profile</a>
        <a href="login.html"    id="loginLink">Sign In</a>
        <a href="register.html" id="registerLink">Register</a>
        <button id="logoutBtn" style="display:none;">Logout</button>
      </nav>
    </div>
  </header>

  <!-- Optional subheader note (lead/tail) -->
<div class="wrap">
  <div id="pageNote" class="page-note"></div>
</div>

<!-- Everything below lives in one container so widths match other pages -->
<div class="wrap">
  <div class="tabs">
    <div class="tab-buttons">
      <button type="button" class="tab-btn" data-tab="my">üìö My Collection</button>
      <button type="button" class="tab-btn" data-tab="global">üåç Global Library</button>
    </div>
    <a id="addBtn" class="btn btn-primary">Add to the Collection</a>
  </div>

  <div class="toolbar">
    <div class="search-bar">
      <input type="text" id="searchInput" placeholder="Search sets..." />
    </div>

    <div class="seg" role="tablist" aria-label="Mode Filter">
      <button type="button" id="f_all"    class="active" aria-pressed="true">All</button>
      <button type="button" id="f_learn">Learn</button>
      <button type="button" id="f_speak">Speak</button>
      <button type="button" id="f_listen">Listen</button>
      <button type="button" id="f_read">Read</button>
    </div>
  </div>

  <div class="card">
    <!-- optional: wrapper so long tables scroll on mobile -->
    <div class="table-wrap">
      <table id="setsTable">
        <thead>
          <tr>
            <th class="sortable" data-key="name">Name <span class="arrow" id="sortName"></span></th>
            <th class="sortable" data-key="count">Cards <span class="arrow" id="sortCount"></span></th>
            <th class="sortable" data-key="type">Type <span class="arrow" id="sortType"></span></th>
            <th>Community</th>
            <th>Your rating</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div id="status" class="muted"></div>
  </div>
</div>

  <!-- Bottom nav -->
  <nav class="bottom" aria-label="Primary">
    <a href="index.html">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M3 10.5L12 3l9 7.5V21a1 1 0 0 1-1 1h-5v-7H9v7H4a 1 1 0 0 1-1-1v-10.5Z" stroke-width="1.5"/></svg>
      <span>Home</span>
    </a>
    <a href="learn.html">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M4 6h16M4 12h16M4 18h9" stroke-width="1.5" stroke-linecap="round"/></svg>
      <span>Learn</span>
    </a>
    <a href="manage_sets/index.html" aria-current="page">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><rect x="3" y="4" width="18" height="16" rx="2" ry="2" stroke-width="1.5"/><path d="M7 8h10M7 12h10M7 16h7" stroke-width="1.5" stroke-linecap="round"/></svg>
      <span>Library</span>
    </a>
    <a href="dashboard.html">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M4 14h6V4H4v10Zm10 6h6V4h-6v16Z" stroke-width="1.5"/></svg>
      <span>Dashboard</span>
    </a>
    <a href="groups.html">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M12 12a5 5 0 1 0-5-5 5 5 0 0 0 5 5Zm-9 9a9 9 0 0 1 18 0" stroke-width="1.5" stroke-linecap="round"/></svg>
      <span>Groups</span>
    </a>
  </nav>

  <!-- Site scripts (order matters): API helper, then chrome (banner/note/auth), then page-specific JS -->
  <script src="static/js/app-config.js"></script>
  <script src="static/js/api.js"></script>
  <script src="static/js/page-chrome.js" defer></script>

<script>
(() => {
  // ---------- Header banner + page note ----------
  const bannerEl = document.getElementById('headerBanner');
  if (bannerEl && !bannerEl.textContent.trim()) {
    const explicit  = document.body.getAttribute('data-header') || document.body.getAttribute('data-banner');
    const fromTitle = (document.title.split('‚Ä¢')[0] || '').trim();
    bannerEl.textContent = explicit || fromTitle || '';
  }

  const noteEl = document.getElementById('pageNote');
  if (noteEl) {
    let lead = (document.body.getAttribute('data-note-lead') || '').trim();
    let tail = (document.body.getAttribute('data-note-tail') || '').trim();

    // Fallback: parse single data-note if both are empty
    if (!lead && !tail) {
      const raw = (document.body.getAttribute('data-note') || '').trim();
      if (raw) {
        const bold = raw.match(/^\s*\*\*(.+?)\*\*\s*(.*)$/); // **Lead** Tail
        if (bold) { lead = bold[1].trim(); tail = bold[2].trim(); }
        else { tail = raw; }
      }
    }

    if (!lead && !tail) {
      noteEl.style.display = 'none';
    } else {
      noteEl.textContent = '';
      if (lead) {
        const L = document.createElement('span');
        L.className = 'note-lead';
        L.textContent = lead;
        noteEl.appendChild(L);
      }
      const noSep = document.body.hasAttribute('data-note-no-sep');
      if (lead && tail && !noSep) {
        const S = document.createElement('span');
        S.className = 'note-sep';
        S.textContent = '‚Äî';
        noteEl.appendChild(S);
      }
      if (tail) {
        const T = document.createElement('span');
        T.className = 'note-tail';
        T.textContent = tail;
        noteEl.appendChild(T);
      }
    }
  }

  // ---------- Auth controls ----------
  const loginLink    = document.getElementById('loginLink');
  const registerLink = document.getElementById('registerLink');
  const logoutBtn    = document.getElementById('logoutBtn');

  (async () => {
    let me = null;
    try {
      const r = await api.fetch('/api/me');
      if (r.ok) me = await r.json();
    } catch(_) {}

    // Expose for the rest of this page (and any other scripts)
    window.LP_ME = me;
    window.LP_IS_ADMIN = !!(me && me.is_admin);

    if (me) {
      loginLink    && (loginLink.style.display    = 'none');
      registerLink && (registerLink.style.display = 'none');
      logoutBtn    && (logoutBtn.style.display    = 'inline-flex');
    } else {
      loginLink    && (loginLink.style.display    = 'inline-flex');
      registerLink && (registerLink.style.display = 'inline-flex');
      logoutBtn    && (logoutBtn.style.display    = 'none');
    }

    logoutBtn?.addEventListener('click', async () => {
      try { await api.fetch('/api/logout', { method:'POST' }); } catch(_){}
      api.clearToken();        // clears lp_token + any future storage
      location.href = 'login.html';
    });
  })();

  // ====================================================================
  // Normalizers / helpers (count + type/modes + labels)
  // ====================================================================
  function firstNonEmpty(obj, keys){
    for (const k of keys){
      if (obj && Object.prototype.hasOwnProperty.call(obj, k)){
        const v = obj[k];
        if (v !== null && v !== undefined && v !== '') return v;
      }
    }
    return undefined;
  }

  function modeLabel(v){
    const s = String(v || '').toLowerCase();
    if (['flashcards','cards','vocab','learn'].includes(s)) return 'Learn';
    if (['speak','speaking','practice'].includes(s)) return 'Speak';
    if (['listen','listening'].includes(s)) return 'Listen';
    if (['read','reading'].includes(s))     return 'Read';
    return s ? s[0].toUpperCase() + s.slice(1) : '‚Äî';
  }

  function pickModes(rec){
    if (!rec) return [];
    if (Array.isArray(rec.modes) && rec.modes.length) return rec.modes;

    const single = firstNonEmpty(rec, ['mode','type','kind','category']);
    if (Array.isArray(single)) return single;
    if (typeof single === 'string'){
      const s = single.toLowerCase();
      if (['flashcards','cards','vocab','learn'].includes(s)) return ['learn','speak'];
      if (['read','reading'].includes(s))    return ['read'];
      if (['listen','listening'].includes(s))return ['listen'];
      if (['speak','speaking','practice'].includes(s)) return ['speak'];
      return [s];
    }
    return [];
  }

  function pickTypeLabel(rec){
    const modes = pickModes(rec);
    if (modes.length){
      const nice = modes.map(modeLabel);
      if (modes.length === 2 && modes.includes('learn') && modes.includes('speak')) {
        return 'Learn / Speak';
      }
      return nice.join(' / ');
    }
    const t = firstNonEmpty(rec, ['type','kind','category']);
    if (!t) return '‚Äî';
    if (String(t).toLowerCase() === 'flashcards') return 'Learn / Speak';
    return modeLabel(t);
  }

  function pickCountValue(rec){
    let n = firstNonEmpty(rec, [
      'count','card_count','cards_count','num_cards','total_cards','terms','term_count','items_count'
    ]);
    if (n === undefined){
      if (Array.isArray(rec.cards)) n = rec.cards.length;
      else if (Array.isArray(rec.items)) n = rec.items.length;
      else if (Array.isArray(rec.terms)) n = rec.terms.length;
    }
    if (typeof n === 'string') n = Number(n);
    return Number.isFinite(n) ? n : -Infinity;
  }

  function pickCountText(rec){
    const v = pickCountValue(rec);
    return v >= 0 ? String(v) : '‚Äî';
  }

  // ====================================================================
  // Ratings helpers
  // ====================================================================
  function loadRatings(){ try{ return JSON.parse(localStorage.getItem('lp.setRatings')||'{}'); }catch{return {};}}
  function saveRatings(map){ localStorage.setItem('lp.setRatings', JSON.stringify(map)); }
  const ratings = loadRatings(); // { [name]: {stars, comment, ts} }

  function starsHtml(n){ const filled='‚òÖ'.repeat(n||0); const empty='‚òÜ'.repeat(Math.max(0,5-(n||0))); return filled+empty; }
  function starsFromAvg(avg){ if(avg==null||Number.isNaN(Number(avg))) return '‚òÜ‚òÜ‚òÜ‚òÜ‚òÜ'; const r=Math.round(Number(avg)); return starsHtml(r); }

  // ====================================================================
  // State
  // ====================================================================
  let globalList = []; // [{name,count,type,created_by?,modes?}]
  let myList = [];     // [{name,count,type,is_owner?,created_by?,modes?}]
  let globalMap = new Map();
  let myMap = new Map();

  const els = {
    search:    document.getElementById('searchInput'),
    table:     document.getElementById('setsTable'),
    tbody:     document.querySelector('#setsTable tbody'),
    status:    document.getElementById('status'),
    sortName:  document.getElementById('sortName'),
    sortCount: document.getElementById('sortCount'),
    sortType:  document.getElementById('sortType'),
    addBtn:    document.getElementById('addBtn'),
    tabs:      document.querySelectorAll('.tab-btn'),

    f_all:     document.getElementById('f_all'),
    f_learn:   document.getElementById('f_learn'),
    f_speak:   document.getElementById('f_speak'),
    f_listen:  document.getElementById('f_listen'),
    f_read:    document.getElementById('f_read'),
  };

  let activeTab  = localStorage.getItem('lp.manage.tab') || 'my';
  let sortKey    = localStorage.getItem('lp.manage.sortKey') || 'name';
  let sortDir    = parseInt(localStorage.getItem('lp.manage.sortDir') || '1', 10); // 1=asc, -1=desc
  els.search.value = localStorage.getItem('lp.manage.q') || '';
  let filterMode = localStorage.getItem('lp.manage.filter') || 'all';

  function rebuildMaps() {
    globalMap = new Map(globalList.map(s => [s.name, s]));
    myMap     = new Map(myList.map(s => [s.name, s]));
  }

  // ====================================================================
  // Normalization for "my" records (used for both endpoints)
  // ====================================================================
  function normalizeMy(raw){
    const arr = Array.isArray(raw) ? raw : [];
    return arr.map(x => {
      const name = x.set_name || x.name || '';
      const g = globalMap.get(name) || {};

      const cv = pickCountValue(x);
      const count = Number.isFinite(cv) && cv >= 0
        ? cv
        : (Number.isFinite(g.count) ? g.count : undefined);

      const modes = (Array.isArray(x.modes) && x.modes.length) ? x.modes
                  : (Array.isArray(g.modes) && g.modes.length) ? g.modes
                  : pickModes(x);

      const type = x.type || g.type || undefined;

      return {
        name,
        is_owner: !!x.is_owner,
        count,
        type,
        modes,
        created_by: x.is_owner ? 'me' : g.created_by
      };
    });
  }

  // ====================================================================
  // Fetchers
  // ====================================================================
  async function fetchGlobal(){
    let r = await api.fetch('/api/global_sets');
    if (r.ok) return r.json();
    r = await api.fetch('/api/sets/available');
    if (r.ok){
      const arr = await r.json();
      return arr.map(x => ({ name:x.name, count:'?', type:'unknown' }));
    }
    return [];
  }

  async function fetchMy(){
    let r = await api.fetch('/api/my_sets'); // legacy
    if (r.status === 401) { alert('Please sign in to manage your sets.'); location.href = 'login.html'; return []; }
    if (r.ok) { const raw = await r.json(); return normalizeMy(raw); }
    r = await api.fetch('/api/my/sets');    // new
    if (r.ok) { const raw = await r.json(); return normalizeMy(raw); }
    return [];
  }

  let aggMap = new Map();
  async function fetchAggregatesFor(names){
    const uniq = Array.from(new Set((names||[]).filter(Boolean)));
    if(!uniq.length) return;
    try{
      const r = await api.fetch('/api/sets/ratings/batch', {
        method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ sets: uniq.slice(0,200) })
      });
      if (r.ok){
        const arr = await r.json();
        arr.forEach(a => aggMap.set(a.set_name, { count:a.count, avg_stars:a.avg_stars }));
        return;
      }
    }catch(_){}
    for (const name of uniq){
      try{
        const rr = await api.fetch('/api/sets/ratings?set='+encodeURIComponent(name));
        if (rr.ok){
          const a = await rr.json();
          aggMap.set(name, { count:a.count, avg_stars:a.avg_stars });
        }
      }catch(_){}
    }
  }

  async function loadSets(){
    try{
      els.status.textContent = 'Loading‚Ä¶';
      globalList = await fetchGlobal();
      rebuildMaps();
      myList = await fetchMy();
      rebuildMaps();

      // Sync your ratings from server
      try{
        const rr = await api.fetch('/api/my/ratings');
        if (rr.ok){
          const server = await rr.json();
          server.forEach(r => { ratings[r.set_name] = { stars:r.stars, comment:r.comment||'', ts: Date.now() }; });
          saveRatings(ratings);
        }
      }catch(_){}

      // Community aggregates
      const names = Array.from(new Set([...globalList.map(s=>s.name), ...myList.map(s=>s.name)])).slice(0,200);
      await fetchAggregatesFor(names);

      els.status.textContent = '';
      renderTable();
    }catch(e){
      console.error(e);
      els.status.textContent = 'Failed to load sets. Is the backend running?';
    }
  }

  // ====================================================================
  // Filtering / sorting / rendering
  // ====================================================================
  function modesFor(set){
    const m = pickModes(set);
    return (Array.isArray(m) && m.length) ? m : ['learn']; // conservative default
  }

  function matchesFilter(set, filter){
    if (filter === 'all') return true;
    return modesFor(set).includes(filter);
  }

  function numVal(v){ const n=typeof v==='number'?v:parseInt(v,10); return Number.isFinite(n)?n:Number.NEGATIVE_INFINITY; }

  function cmp(a,b,key){
    if (key === 'count') {
      const av = pickCountValue(a), bv = pickCountValue(b);
      if (av !== bv) return av - bv;
      return String(a.name).localeCompare(String(b.name));
    }
    if (key === 'type') {
      const ad = pickTypeLabel(a);
      const bd = pickTypeLabel(b);
      return ad.localeCompare(bd, undefined, {sensitivity:'base'});
    }
    const av = a[key], bv = b[key];
    return String(av||'').localeCompare(String(bv||''), undefined, {sensitivity:'base'});
  }

  function sortList(list){
    const arr = list.slice().sort((a,b)=>cmp(a,b,sortKey)*sortDir);
    els.sortName.textContent  = sortKey==='name'  ? (sortDir>0?'‚ñ≤':'‚ñº') : '';
    els.sortCount.textContent = sortKey==='count' ? (sortDir>0?'‚ñ≤':'‚ñº') : '';
    els.sortType.textContent  = sortKey==='type'  ? (sortDir>0?'‚ñ≤':'‚ñº') : '';
    return arr;
  }

  function makeCell(text){ const td=document.createElement('td'); td.textContent=text; return td; }

  function renderTable(){
    els.tbody.innerHTML = '';
    const q = els.search.value.toLowerCase().trim();
    const baseList = (activeTab==='my' ? myList : globalList)
      .filter(s => matchesFilter(s, filterMode))
      .filter(s => (s.name||'').toLowerCase().includes(q));

    const list = sortList(baseList);

    list.forEach(set=>{
      const tr = document.createElement('tr');
      const inMyLib = myMap.has(set.name);

      tr.appendChild(makeCell(set.name));
      tr.appendChild(makeCell(pickCountText(set)));     // <- normalized count
      tr.appendChild(makeCell(pickTypeLabel(set)));     // <- from modes/type

      // Community
      const tdCommunity = document.createElement('td');
      const agg = aggMap.get(set.name);
      if (agg && agg.avg_stars != null){
        const avgSpan = document.createElement('span');
        avgSpan.className = 'rating';
        avgSpan.textContent = starsFromAvg(agg.avg_stars);
        const meta = document.createElement('span');
        meta.className = 'muted';
        meta.textContent = ` ${agg.avg_stars.toFixed(1)} (${agg.count})`;
        tdCommunity.appendChild(avgSpan);
        tdCommunity.appendChild(meta);
      }else{
        tdCommunity.textContent = '‚Äî';
      }
      tr.appendChild(tdCommunity);

      // Your rating
      const tdRate = document.createElement('td');
      const mine = ratings[set.name] || {};
      const span = document.createElement('span');
      span.className = 'rating';
      span.textContent = starsHtml(mine.stars || 0);
      tdRate.appendChild(span);

      const rateBtn = document.createElement('button');
      rateBtn.className = 'btn';
      rateBtn.dataset.set = set.name;
      rateBtn.textContent = 'Rate';
      tdRate.appendChild(document.createTextNode(' '));
      tdRate.appendChild(rateBtn);
      tr.appendChild(tdRate);

      // Actions
      const tdAct = document.createElement('td');
      if (activeTab === 'my') {
        const rm = document.createElement('button'); rm.className='action-btn remove-btn'; rm.dataset.set=set.name; rm.textContent='Remove'; tdAct.appendChild(rm);
        const isOwner = !!(myMap.get(set.name)?.is_owner)
              || !globalMap.has(set.name)
              || (window.LP_IS_ADMIN === true);

        if (isOwner){
          const del = document.createElement('button'); del.className='delete-link'; del.dataset.set=set.name; del.title='Delete the set file (use only for upload mistakes)'; del.textContent='Delete permanently';
          tdAct.appendChild(document.createTextNode(' ')); tdAct.appendChild(del);
        }
      } else {
        if (inMyLib){
          const spanIn = document.createElement('span'); spanIn.className='muted'; spanIn.textContent='‚úîÔ∏è In Library'; tdAct.appendChild(spanIn);
        }else{
          const imp = document.createElement('button'); imp.className='action-btn import-btn'; imp.dataset.set=set.name; imp.textContent='Import'; tdAct.appendChild(imp);
        }
      }
      tr.appendChild(tdAct);

      if (activeTab === 'global' && inMyLib) tr.classList.add('in-library');
      els.tbody.appendChild(tr);
    });
  }

  // Inline rating editor row
  function toggleEditorRow(afterTr, setName){
    const next = afterTr.nextElementSibling;
    if (next && next.classList.contains('edit-row')){ next.remove(); return; }
    document.querySelectorAll('.edit-row').forEach(n => n.remove());

    const r = ratings[setName] || { stars:0, comment:'' };
    const tr = document.createElement('tr'); tr.className='edit-row';
    const td = document.createElement('td'); td.colSpan=6;
    td.innerHTML = `
      <div class="edit-wrap" data-set="${setName}">
        <div class="rating" aria-label="Choose rating">
          ${[1,2,3,4,5].map(n => `<span class="star" data-val="${n}">${n <= (r.stars||0) ? '‚òÖ' : '‚òÜ'}</span>`).join('')}
        </div>
        <textarea placeholder="Leave a short comment...">${r.comment || ''}</textarea>
        <button class="btn btn-primary save-rating">Save</button>
        <button class="btn cancel-rating">Cancel</button>
        <span class="muted">(Saves to server)</span>
      </div>
    `;
    tr.appendChild(td);
    afterTr.insertAdjacentElement('afterend', tr);
  }

  // Actions (delegation)
  els.table.addEventListener('click', async (ev)=>{
    const btn = ev.target.closest('button');
    const cellStar = ev.target.classList.contains('star') ? ev.target : null;

    if (cellStar){
      const wrap = cellStar.closest('.edit-wrap'); if(!wrap) return;
      const val = parseInt(cellStar.dataset.val, 10);
      wrap.querySelectorAll('.star').forEach((s,i)=> s.textContent = (i < val ? '‚òÖ' : '‚òÜ'));
      wrap.dataset.stars = String(val);
      return;
    }
    if (!btn) return;
    const setName = btn.dataset.set || (btn.closest('.edit-wrap')?.dataset.set);

    try{
      if (btn.textContent === 'Rate'){
        const tr = btn.closest('tr'); toggleEditorRow(tr, setName); return;
      }
      if (btn.classList.contains('save-rating')){
        const wrap = btn.closest('.edit-wrap');
        const stars = parseInt(wrap.dataset.stars || '0', 10);
        const comment = wrap.querySelector('textarea').value.trim();
        try{
          await api.fetch('/api/sets/rate', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ set_name:setName, stars, comment }) });
        }catch{}
        ratings[setName] = { stars, comment, ts: Date.now() }; saveRatings(ratings);
        const row = wrap.closest('tr').previousElementSibling;
        const ratingCell = row.children[4].querySelector('.rating'); ratingCell.textContent = starsHtml(stars);
        wrap.closest('tr').remove();
        els.status.textContent = `Saved rating for "${setName}".`;
        try{ await fetchAggregatesFor([setName]); renderTable(); }catch(_){}
        return;
      }
      if (btn.classList.contains('cancel-rating')){ btn.closest('.edit-row').remove(); return; }

      if (btn.classList.contains('import-btn')){
        let r = await api.fetch('/api/my/sets', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ set_name:setName }) });
        if (!r.ok){
          r = await api.fetch('/api/add_set', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ set_name:setName }) });
        }
        if (!r.ok) throw new Error('import failed');

        const g = globalMap.get(setName) || {};
        myMap.set(setName, {
          name: setName,
          count: (function(){ const v = pickCountValue(g); return Number.isFinite(v) && v >= 0 ? v : undefined; })(),
          type: g.type,
          modes: Array.isArray(g.modes) && g.modes.length ? g.modes : pickModes(g),
          is_owner: false
        });
        myList = Array.from(myMap.values()); rebuildMaps(); renderTable();
        els.status.textContent = `Imported "${setName}".`; return;
      }

      if (btn.classList.contains('remove-btn')){
        let r = await api.fetch('/api/my/sets/'+encodeURIComponent(setName), { method:'DELETE' });
        if (!r.ok){
          r = await api.fetch('/api/remove_set', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ set_name:setName }) });
        }
        if (!r.ok) throw new Error('remove failed');
        myMap.delete(setName); myList = Array.from(myMap.values()); rebuildMaps(); renderTable();
        els.status.textContent = `Removed "${setName}" from your library.`; return;
      }

      if (btn.classList.contains('delete-link')){
        if (!confirm(`Delete your set "${setName}"? This removes the set file for everyone. This cannot be undone.`)) return;
        const r = await api.fetch('/api/delete_set/'+encodeURIComponent(setName), { method:'POST' });
        if (!r.ok) throw new Error('delete failed');
        myMap.delete(setName); myList = Array.from(myMap.values());
        globalMap.delete(setName); globalList = globalList.filter(s=>s.name!==setName);
        rebuildMaps(); renderTable();
        els.status.textContent = `Deleted "${setName}".`; return;
      }
    }catch(e){ console.error(e); els.status.textContent = 'Action failed.'; }
  });

  // Sorting
  document.querySelectorAll('th.sortable').forEach(th=>{
    th.addEventListener('click', ()=>{
      const key = th.dataset.key;
      if (sortKey===key){ sortDir = -sortDir; } else { sortKey = key; sortDir = 1; }
      localStorage.setItem('lp.manage.sortKey', sortKey);
      localStorage.setItem('lp.manage.sortDir', String(sortDir));
      renderTable();
    });
  });

  // Tabs
  document.querySelectorAll('.tab-btn').forEach(btn=> btn.addEventListener('click', ()=> setActiveTab(btn.dataset.tab)));
  function setActiveTab(tab) {
    activeTab = tab;
    localStorage.setItem('lp.manage.tab', tab);
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('active', b.dataset.tab === tab));
    renderTable();
  }

  // Mode filter events
  els.f_all.addEventListener('click',   ()=> setActiveFilter('all'));
  els.f_learn.addEventListener('click', ()=> setActiveFilter('learn'));
  els.f_speak.addEventListener('click', ()=> setActiveFilter('speak'));
  els.f_listen.addEventListener('click',()=> setActiveFilter('listen'));
  els.f_read.addEventListener('click',  ()=> setActiveFilter('read'));

  function setActiveFilter(key){
    filterMode = key;
    localStorage.setItem('lp.manage.filter', key);
    ['all','learn','speak','listen','read'].forEach(k=>{
      const btn = els['f_'+k];
      if (btn){
        btn.classList.toggle('active', k===key);
        btn.setAttribute('aria-pressed', k===key ? 'true' : 'false');
      }
    });
    renderTable();
  }

 // Search (debounced)
  els.search.addEventListener('input', (function debounce(fn,ms){ let t; return ()=>{ clearTimeout(t); t=setTimeout(fn,ms) } })(()=>{
    localStorage.setItem('lp.manage.q', els.search.value);
    renderTable();
  }, 200));

  // Fix create link per host
  (function wireAddButton(){
    if (!els.addBtn) return;
    els.addBtn.href = (location.hostname.endsWith('github.io')) ? 'create.html' : '/create_page';
  })();

  // Init
  (async function init(){
    setActiveTab(activeTab);
    setActiveFilter(filterMode);
    await loadSets();
    // console.log('SAMPLE myList', myList.slice(0,3)); // <- optional debug
  })();
})();
</script>

</body>
</html>
