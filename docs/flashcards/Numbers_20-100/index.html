<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Dual-host <base>: GitHub Pages vs Flask -->
  <script>
    (function () {
      var isGH = /\.github\.io$/i.test(location.hostname);
      var baseHref = isGH ? '/LearnPolish/' : '/';
      document.write('<base href="' + baseHref + '">');
    })();
  </script>

  <title>Numbers_20-100 ‚Ä¢ Learn ‚Ä¢ Path to POLISH</title>

  <!-- Site styles -->
  <link rel="stylesheet" href="static/app.css?v=5">

  <style>
    .wrap{ max-width:900px; margin:0 auto; padding:0 16px 80px; }
    .learn-frame{ display:grid; gap:16px; grid-template-columns:1fr; }
    @media (min-width:880px){ .learn-frame{ grid-template-columns: 1.1fr .9fr; } }

    .card.flip {
      width:100%; height:320px; perspective:1000px; margin:8px 0;
      background:none; border:none; box-shadow:none; padding:0;
    }
    .flip-inner {
      width:100%; height:100%; position:relative; transition:transform .6s; transform-style:preserve-3d;
      cursor:pointer;
    }
    .flip.flipped .flip-inner { transform: rotateY(180deg); }
    .face {
      position:absolute; inset:0; border-radius:var(--radius);
      background:var(--card); border:1px solid var(--border);
      display:flex; flex-direction:column; align-items:center; justify-content:center; text-align:center; padding:18px;
      backface-visibility:hidden;
    }
    .face.back { transform:rotateY(180deg); background:var(--bg); }

    .cue { font-size:18px; color:var(--muted); }
    .phrase { font-size:22px; font-weight:700; }
    .pron { margin-top:6px; font-style:italic; color:var(--muted); }

    .act-row{ display:flex; gap:8px; margin-top:14px; }
    .result{ margin-top:8px; min-height:1.2em; }

    /* Level meter (capture mode) */
    #meterWrap { display:none; margin-top:10px; width:260px; height:8px; background:#e6e6ef; border-radius:999px; overflow:hidden; }
    #meterBar  { width:0%; height:100%; background:var(--brand); }

    /* Debug overlay */
    #dbg { display:none; position:fixed; bottom:8px; left:8px; right:8px; max-height:46vh; overflow:auto;
           background:#000; color:#0f0; padding:8px 10px; border-radius:10px; font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
           font-size:12px; white-space:pre-wrap; z-index:9999; }
    #dbg .raw { color:#9ef; }
  </style>
</head>

<body
  data-header="Path to Polish"
  data-note-lead="Flashcards"
  data-note-tail="Numbers_20-100"
  style="--logo-size: 40px; --banner-size: 24px; --banner-size-lg: 30px;">

  <!-- Header -->
  <header class="topbar no-nav">
    <div class="row container">
      <div class="header-left">
        <a class="brand" href="index.html" aria-label="Path to Polish ‚Äî Home">
          <svg class="brand-mark" aria-hidden="true" focusable="false">
            <use href="static/brand.svg#ptp-mark"></use>
          </svg>
          <span id="headerBanner" class="header-banner"></span>
        </a>
      </div>
      <nav class="head-actions">
        <a href="profile.html"  id="profileBtn">Profile</a>
        <a href="login.html"    id="loginLink">Sign In</a>
        <a href="register.html" id="registerLink">Register</a>
        <button id="logoutBtn" style="display:none;">Logout</button>
      </nav>
    </div>
  </header>

  <!-- (No "how it works" / "scoring" sidebar, no hint line) -->
  <main class="wrap learn-frame">
    <!-- LEFT: Card -->
    <section class="stack">
      <div class="card flip" id="cardContainer" aria-live="polite">
        <div class="flip-inner" id="cardInner">
          <div class="face front" id="frontSide">
            <div class="cue" id="frontCue"></div>
            <div class="act-row">
              <button class="btn btn-primary" id="btnSayFront" title="Record then score">üé§ Say it in Polish</button>
            </div>
            <div id="meterWrap"><div id="meterBar"></div></div>
            <a id="dlWav" class="btn tiny" download="capture.wav" style="display:none;">‚¨áÔ∏è Download capture</a>
            <div class="result" id="frontResult"></div>
          </div>
          <div class="face back" id="backSide">
            <div class="phrase" id="answerPhrase"></div>
            <div class="pron"   id="answerPron"></div>
            <div class="act-row">
              <button class="btn" id="btnPlay">üîä Play</button>
            </div>
            <div class="result" id="backResult"></div>
          </div>
        </div>
      </div>

      <div class="row">
        <button id="prevBtn" class="btn">Previous</button>
        <button id="nextBtn" class="btn btn-primary">Next</button>
      </div>
    </section>

    <!-- RIGHT: Offline audio helper (temporarily hidden) -->
    <aside class="stack" style="display:none;">
      <section class="card">
        <div class="title" style="font-size:16px; font-weight:600; margin-bottom:4px;">Offline audio</div>
        <div class="act-row" style="margin-top:8px;">
          <button id="offlineBtn" class="btn">‚¨áÔ∏è Download</button>
          <button id="offlineRemoveBtn" class="btn" style="display:none;">üóë Remove</button>
        </div>
        <div id="offlineStatus" class="result" style="margin-top:8px;"></div>
      </section>
    </aside>
  </main>

  <div id="dbg"></div>

  <!-- Bottom nav -->
  <nav class="bottom" aria-label="Primary">
    <a href="index.html">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M3 10.5L12 3l9 7.5V21a1 1 0 0 1-1 1h-5v-7H9v7H4a1 1 0 0 1-1-1v-10.5Z" stroke-width="1.5"/></svg>
      <span>Home</span>
    </a>
    <a href="learn.html" class="active" aria-current="page">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M4 6h16M4 12h16M4 18h9" stroke-width="1.5" stroke-linecap="round"/></svg>
      <span>Learn</span>
    </a>
    <a href="manage_sets/index.html">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><rect x="3" y="4" width="18" height="16" rx="2" ry="2" stroke-width="1.5"/><path d="M7 8h10M7 12h10M7 16h7" stroke-width="1.5" stroke-linecap="round"/></svg>
      <span>Library</span>
    </a>
    <a href="dashboard.html">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M4 14h6V4H4v10Zm10 6h6V4h-6v16Z" stroke-width="1.5"/></svg>
      <span>Dashboard</span>
    </a>
    <a href="groups.html">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M12 12a5 5 0 1 0-5-5 5 5 0 0 0 5 5Zm-9 9a9 9 0 0 1 18 0" stroke-width="1.5" stroke-linecap="round"/></svg>
      <span>Groups</span>
    </a>
  </nav>

  <!-- Scripts -->
  <script src="static/js/app-config.js"></script>
  <script src="static/js/api.js"></script>
  <script src="static/js/page-chrome.js" defer></script>
  <script src="static/js/audio-paths.js"></script>
  <script src="static/js/results.js"></script>
  <script src="https://aka.ms/csspeech/jsbrowserpackageraw"></script>

  <script>
    // --- Data & state ---
    const cards = [{"phrase": "Dwadzie≈õcia", "meaning": "Twenty", "pronunciation": "dva-JYESH-chah", "audio_file": "0_Dwadziescia.mp3"}, {"phrase": "Dwadzie≈õcia siedem", "meaning": "Twenty-seven", "pronunciation": "dva-JYESH-chah SHYEH-dem", "audio_file": "1_Dwadziescia_siedem.mp3"}, {"phrase": "Trzydzie≈õci", "meaning": "Thirty", "pronunciation": "tshi-JYESH-chee", "audio_file": "2_Trzydziesci.mp3"}, {"phrase": "Trzydzie≈õci jeden", "meaning": "Thirty-one", "pronunciation": "tshi-JYESH-chee YEH-den", "audio_file": "3_Trzydziesci_jeden.mp3"}, {"phrase": "Czterdzie≈õci", "meaning": "Forty", "pronunciation": "chter-JYESH-chee", "audio_file": "4_Czterdziesci.mp3"}, {"phrase": "Czterdzie≈õci dwa", "meaning": "Forty-two", "pronunciation": "chter-JYESH-chee dvah", "audio_file": "5_Czterdziesci_dwa.mp3"}, {"phrase": "PiƒôƒádziesiƒÖt", "meaning": "Fifty", "pronunciation": "pyench-JYEH-shont", "audio_file": "6_Piecdziesiat.mp3"}, {"phrase": "PiƒôƒádziesiƒÖt trzy", "meaning": "Fifty-three", "pronunciation": "pyench-JYEH-shont tshih", "audio_file": "7_Piecdziesiat_trzy.mp3"}, {"phrase": "Sze≈õƒádziesiƒÖt", "meaning": "Sixty", "pronunciation": "sheshch-JYEH-shont", "audio_file": "8_Szescdziesiat.mp3"}, {"phrase": "Sze≈õƒádziesiƒÖt cztery", "meaning": "Sixty-four", "pronunciation": "sheshch-JYEH-shont CHTEH-rih", "audio_file": "9_Szescdziesiat_cztery.mp3"}, {"phrase": "SiedemdziesiƒÖt", "meaning": "Seventy", "pronunciation": "shyeh-dem-JYEH-shont", "audio_file": "10_Siedemdziesiat.mp3"}, {"phrase": "SiedemdziesiƒÖt piƒôƒá", "meaning": "Seventy-five", "pronunciation": "shyeh-dem-JYEH-shont pyench", "audio_file": "11_Siedemdziesiat_piec.mp3"}, {"phrase": "OsiemdziesiƒÖt", "meaning": "Eighty", "pronunciation": "oh-shyem-JYEH-shont", "audio_file": "12_Osiemdziesiat.mp3"}, {"phrase": "OsiemdziesiƒÖt sze≈õƒá", "meaning": "Eighty-six", "pronunciation": "oh-shyem-JYEH-shont sheshch", "audio_file": "13_Osiemdziesiat_szesc.mp3"}, {"phrase": "DziewiƒôƒádziesiƒÖt", "meaning": "Ninety", "pronunciation": "jyeh-vyench-JYEH-shont", "audio_file": "14_Dziewiecdziesiat.mp3"}, {"phrase": "DziewiƒôƒádziesiƒÖt dziewiƒôƒá", "meaning": "Ninety-nine", "pronunciation": "jyeh-vyench-JYEH-shont jyeh-vyench", "audio_file": "15_Dziewiecdziesiat_dziewiec.mp3"}, {"phrase": "Sto", "meaning": "One hundred", "pronunciation": "stoh", "audio_file": "16_Sto.mp3"}, {"phrase": "Sto piƒôƒá", "meaning": "One hundred five", "pronunciation": "stoh pyench", "audio_file": "17_Sto_piec.mp3"}, {"phrase": "Dwie≈õcie", "meaning": "Two hundred", "pronunciation": "d-vyeh-sh-cheh", "audio_file": "18_Dwiescie.mp3"}, {"phrase": "Dwie≈õcie dziesiƒôƒá", "meaning": "Two hundred ten", "pronunciation": "d-vyeh-sh-cheh jyeh-shyench", "audio_file": "19_Dwiescie_dziesiec.mp3"}, {"phrase": "Trzysta", "meaning": "Three hundred", "pronunciation": "tshih-stah", "audio_file": "20_Trzysta.mp3"}, {"phrase": "Trzysta dwadzie≈õcia", "meaning": "Three hundred twenty", "pronunciation": "tshih-stah dva-JYESH-chah", "audio_file": "21_Trzysta_dwadziescia.mp3"}, {"phrase": "Czterysta", "meaning": "Four hundred", "pronunciation": "chter-ih-stah", "audio_file": "22_Czterysta.mp3"}, {"phrase": "Czterysta trzydzie≈õci", "meaning": "Four hundred thirty", "pronunciation": "chter-ih-stah tshi-JYESH-chee", "audio_file": "23_Czterysta_trzydziesci.mp3"}, {"phrase": "Piƒôƒáset", "meaning": "Five hundred", "pronunciation": "pyench-set", "audio_file": "24_Piecset.mp3"}, {"phrase": "Piƒôƒáset czterdzie≈õci", "meaning": "Five hundred forty", "pronunciation": "pyench-set chter-JYESH-chee", "audio_file": "25_Piecset_czterdziesci.mp3"}, {"phrase": "Sze≈õƒáset", "meaning": "Six hundred", "pronunciation": "sheshch-set", "audio_file": "26_Szescset.mp3"}, {"phrase": "Sze≈õƒáset piƒôƒádziesiƒÖt", "meaning": "Six hundred fifty", "pronunciation": "sheshch-set pyench-JYEH-shont", "audio_file": "27_Szescset_piecdziesiat.mp3"}, {"phrase": "Siedemset", "meaning": "Seven hundred", "pronunciation": "shyeh-dem-set", "audio_file": "28_Siedemset.mp3"}, {"phrase": "Siedemset sze≈õƒádziesiƒÖt", "meaning": "Seven hundred sixty", "pronunciation": "shyeh-dem-set sheshch-JYEH-shont", "audio_file": "29_Siedemset_szescdziesiat.mp3"}, {"phrase": "Osiemset", "meaning": "Eight hundred", "pronunciation": "oh-shyem-set", "audio_file": "30_Osiemset.mp3"}, {"phrase": "Osiemset siedemdziesiƒÖt", "meaning": "Eight hundred seventy", "pronunciation": "oh-shyem-set shyeh-dem-JYEH-shont", "audio_file": "31_Osiemset_siedemdziesiat.mp3"}, {"phrase": "Dziewiƒôƒáset", "meaning": "Nine hundred", "pronunciation": "jyeh-vyench-set", "audio_file": "32_Dziewiecset.mp3"}, {"phrase": "Dziewiƒôƒáset osiemdziesiƒÖt", "meaning": "Nine hundred eighty", "pronunciation": "jyeh-vyench-set oh-shyem-JYEH-shont", "audio_file": "33_Dziewiecset_osiemdziesiat.mp3"}, {"phrase": "TysiƒÖc", "meaning": "One thousand", "pronunciation": "TISH-yon-ts", "audio_file": "34_Tysiac.mp3"}, {"phrase": "TysiƒÖc dwadzie≈õcia", "meaning": "One thousand twenty", "pronunciation": "TISH-yon-ts dva-JYESH-chah", "audio_file": "35_Tysiac_dwadziescia.mp3"}];
    const setName = "Numbers_20-100";
    const mode = "flashcards";
    let currentIndex = 0;

    // CDN manifest
    let r2Manifest = null;

    // Debug overlay
    const DEBUG = new URL(location.href).searchParams.get('debug') === '1';
    const dbgEl = document.getElementById('dbg');
    if (DEBUG) dbgEl.style.display = 'block';
    function logDbg(...a) {
      if (!DEBUG) return;
      const line = document.createElement('div');
      line.className = 'row';
      line.textContent = a.map(x => (typeof x === 'string' ? x : JSON.stringify(x))).join(' ');
      dbgEl.appendChild(line); dbgEl.scrollTop = dbgEl.scrollHeight;
      try { console.debug('[FC]', ...a); } catch(_) {}
    }
    function logRaw(j) {
      if (!DEBUG) return;
      const line = document.createElement('div');
      line.className = 'row raw';
      line.textContent = (typeof j === 'string') ? j : JSON.stringify(j);
      dbgEl.appendChild(line); dbgEl.scrollTop = dbgEl.scrollHeight;
    }

    // URL overrides (default capture)
    const URLP = new URL(location.href).searchParams;
    const FORCE_LIVE = URLP.get('live') === '1';
    const capQ = URLP.get('capture');
    const CAPTURE_MODE = FORCE_LIVE ? false : (capQ === '0' ? false : true);

    // Scoring + points
    const DIFF_PRESETS = { easy: 65, normal: 75, hard: 85 };

    function resolveDifficulty(storageKey) {
      let d = "normal";
      try {
        if (window.userPrefs && window.userPrefs.pronDifficulty) {
          d = String(window.userPrefs.pronDifficulty || "").toLowerCase();
        } else {
          const stored = localStorage.getItem(storageKey);
          if (stored) d = String(stored).toLowerCase();
        }
      } catch (_e) {}
      if (d !== "easy" && d !== "normal" && d !== "hard") d = "normal";
      return d;
    }

    let difficulty = resolveDifficulty("lp.diff_flashcards");
    function currentPassThreshold() {
      return DIFF_PRESETS[difficulty] || 75;
    }

    const tracker = { attempts: 0, per: {}, perfectNoFlipCount: 0 };
    let hasFlippedCurrent = false;

    // Audio preload
    const audioCache = new Map();
    function sanitizeFilename(text) {
      return (text || "")
        .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
        .replace(/[^a-zA-Z0-9_-]+/g, "_").replace(/^_+|_+$/g, "");
    }
    function localAudioPath(index) {
      const e = cards[index] || {};
      const fn = String(index) + "_" + sanitizeFilename(e.phrase || "") + ".mp3";
      const setEnc = encodeURIComponent(setName);
      const fnEnc  = encodeURIComponent(fn);
      const explicit = e.audio_url || e.audio;
      if (explicit && /^https?:\/\//i.test(explicit)) return explicit;
      return "static/" + setEnc + "/audio/" + fnEnc; // base href handles nesting
    }
    function buildAudioSrc(index) {
      let src = localAudioPath(index);
      try {
        if (window.AudioPaths) src = AudioPaths.buildAudioPath(setName, index, cards[index], r2Manifest);
      } catch(_e) {}
      return src;
    }
    function primeAudio(index) {
      if (index < 0 || index >= cards.length) return;
      if (audioCache.has(index)) return;
      const a = new Audio();
      a.preload = "auto";
      a.src = buildAudioSrc(index);
      try { a.load(); } catch(_e) {}
      audioCache.set(index, a);
    }

    // ----- Offline audio helpers (Flashcards) -----
    async function ensureSW() {
      if (!('serviceWorker' in navigator)) return null;
      try {
        const reg = await navigator.serviceWorker.register('./sw.js', { scope: './' });
        await navigator.serviceWorker.ready;
        return reg;
      } catch(e) {
        logDbg('SW register failed', e && e.message ? e.message : e);
        return null;
      }
    }

    function allAudioUrls() {
      const urls = [];
      for (let i = 0; i < cards.length; i++) {
        urls.push(buildAudioSrc(i));
      }
      return Array.from(new Set(urls));
    }

    function resetAndPrimeAround(index) {
      audioCache.clear();
      primeAudio(index);
      primeAudio(index + 1);
    }

    function setNavUI() {
      document.getElementById("prevBtn").disabled = (currentIndex === 0);
      document.getElementById("nextBtn").textContent =
        (currentIndex < cards.length - 1) ? "Next" : "Finish";
    }

    function renderCard() {
      const e = cards[currentIndex] || {};
      document.getElementById("frontCue").textContent   = e.meaning || "";
      document.getElementById("frontResult").textContent= "";
      document.getElementById("answerPhrase").textContent = e.phrase || "";
      document.getElementById("answerPron").textContent   = e.pronunciation || "";
      document.getElementById("backResult").textContent   = "";
      // Always flip to FRONT on render:
      document.getElementById("cardContainer").classList.remove("flipped");
      hasFlippedCurrent = false;
      setNavUI();
      resetAndPrimeAround(currentIndex);
    }

    // ---------- Token cache ----------
    const tokenCache = { token: null, region: null, exp: 0 };
    async function fetchToken() {
      const now = Date.now();
      if (tokenCache.token && tokenCache.region && now < tokenCache.exp) return tokenCache;
      try {
        const tok = await api.get('/api/speech_token', { noAuth: true });
        const token  = tok && (tok.token || tok.access_token);
        const region = tok && (tok.region || tok.location || tok.regionName);
        if (!token || !region) throw new Error('no_token_or_region');
        tokenCache.token  = token;
        tokenCache.region = region;
        tokenCache.exp    = now + 9 * 60 * 1000;
        logDbg('SDK?', !!window.SpeechSDK, 'region', region, 'tok', !!token);
        return tokenCache;
      } catch(e) {
        logDbg('token fetch error', e && e.message ? e.message : e);
        return { token: null, region: null, exp: 0 };
      }
    }
    async function prefetchToken() {
      try { await fetchToken(); } catch(_e) {}
    }

    // ---------- Early-stop capture with voiced-ms tracking ----------
    const meterWrap = document.getElementById('meterWrap');
    const meterBar  = document.getElementById('meterBar');
    const dlWav     = document.getElementById('dlWav');

    async function recordBlobVAD(maxMs = 2200) {
      meterWrap.style.display = CAPTURE_MODE ? 'block' : 'none';

      let mediaStream = null, mediaRec = null, chunks = [];
      let analyser = null, data = null, ctx = null, src = null;
      let meterTimer = null, started = false, silentMs = 0, voicedMs = 0, startedAt = 0;

      try {
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        // VAD
        try {
          const ACtx = window.AudioContext || window.webkitAudioContext;
          if (ACtx) {
            ctx = new ACtx();
            src = ctx.createMediaStreamSource(mediaStream);
            analyser = ctx.createAnalyser();
            analyser.fftSize = 2048;
            src.connect(analyser);
            data = new Uint8Array(analyser.fftSize);
          }
        } catch(_e) {}

        mediaRec = new MediaRecorder(mediaStream, { mimeType: 'audio/webm' });
        mediaRec.ondataavailable = function(e) {
          if (e.data && e.data.size) chunks.push(e.data);
        };
        const stopNow = function() {
          try {
            if (mediaRec && mediaRec.state !== 'inactive') mediaRec.stop();
          } catch(_e) {}
        };
        mediaRec.start();

        const t0 = performance.now();
        const THRESH = 0.038;      // speech trigger (RMS)
        const SIL_HOLD = 420;      // ms of silence to stop after speech

        await new Promise(function(resolve) {
          meterTimer = setInterval(function() {
            const t = performance.now();
            if (analyser && data) {
              analyser.getByteTimeDomainData(data);
              let sum = 0;
              for (let i = 0; i < data.length; i++) {
                const v = (data[i] - 128) / 128;
                sum += v * v;
              }
              const rms = Math.sqrt(sum / data.length);
              meterBar.style.width = Math.min(100, Math.round(rms * 180)) + '%';

              if (!started && rms > THRESH) {
                started = true;
                startedAt = t;
              } else if (started) {
                if (rms > THRESH * 0.75) voicedMs += 40;           // voiced frame
                if (rms < THRESH * 0.6) silentMs += 40; else silentMs = 0;
                if (silentMs >= SIL_HOLD && (t - startedAt) > 260) stopNow();
              }
            }
            if ((t - t0) > maxMs) stopNow();
          }, 40);

          mediaRec.onstop = resolve;
        });

        return { blob: new Blob(chunks, { type: 'audio/webm' }), voicedMs: voicedMs };
      } finally {
        try { if (meterTimer) clearInterval(meterTimer); } catch(_e) {}
        try { meterBar.style.width = '0%'; } catch(_e) {}
        try {
          if (mediaStream) mediaStream.getTracks().forEach(function(t) { t.stop(); });
        } catch(_e) {}
        try { if (ctx) ctx.close(); } catch(_e) {}
        meterWrap.style.display = 'none';
      }
    }

    async function blobToPCM16Mono(blob, targetRate = 16000) {
      const arr = await blob.arrayBuffer();
      const ACtx = window.AudioContext || window.webkitAudioContext;
      if (!ACtx) throw new Error('no_audiocontext');
      const ctx = new ACtx();
      const buf = await ctx.decodeAudioData(arr.slice(0));
      const chL = buf.getChannelData(0);
      let mono;
      if (buf.numberOfChannels > 1) {
        const chR = buf.getChannelData(1);
        mono = new Float32Array(buf.length);
        for (let i = 0; i < buf.length; i++) mono[i] = 0.5 * (chL[i] + chR[i]);
      } else {
        mono = chL;
      }
      const ratio = buf.sampleRate / targetRate;
      const outLen = Math.round(mono.length / ratio);
      const out = new Float32Array(outLen);
      for (let i = 0; i < outLen; i++) {
        const idx = i * ratio;
        const i0 = Math.floor(idx);
        const i1 = Math.min(i0 + 1, mono.length - 1);
        const frac = idx - i0;
        out[i] = mono[i0] * (1 - frac) + mono[i1] * frac;
      }
      const pcm = new Int16Array(outLen);
      for (let j = 0; j < outLen; j++) {
        let v = Math.max(-1, Math.min(1, out[j]));
        pcm[j] = v < 0 ? v * 0x8000 : v * 0x7FFF;
      }
      try { ctx.close(); } catch(_e) {}
      return pcm;
    }

    function pcmToWavBlob(pcm, sampleRate = 16000) {
      const numFrames = pcm.length;
      const bytesPerSample = 2;
      const blockAlign = bytesPerSample;
      const byteRate = sampleRate * blockAlign;
      const dataSize = numFrames * bytesPerSample;
      const buf = new ArrayBuffer(44 + dataSize);
      const v = new DataView(buf);
      let o = 0;
      function wstr(s) { for (let i = 0; i < s.length; i++) v.setUint8(o++, s.charCodeAt(i)); }
      function wu16(x) { v.setUint16(o, x, true); o += 2; }
      function wu32(x) { v.setUint32(o, x, true); o += 4; }
      wstr('RIFF'); wu32(36 + dataSize); wstr('WAVE'); wstr('fmt '); wu32(16); wu16(1); wu16(1);
      wu32(sampleRate); wu32(byteRate); wu16(blockAlign); wu16(16); wstr('data'); wu32(dataSize);
      for (let i = 0; i < pcm.length; i++) v.setInt16(o + i * 2, pcm[i], true);
      return new Blob([v], { type: 'audio/wav' });
    }

    // ---- Stricter scoring helpers ----
    function extractPAJson(result, SDK) {
      try {
        const raw = (result && result.properties && result.properties.getProperty)
          ? result.properties.getProperty(SDK.PropertyId.SpeechServiceResponse_JsonResult)
          : null;
        const v = raw || result.privPronunciationAssessmentJson || result.privJson;
        if (!v) return null;
        try { return JSON.parse(v); } catch(_e) {
          return null;
        }
      } catch(_e) {
        return null;
      }
    }

    function estimateSyllablesPL(text) {
      const t = String(text || "").toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
      const vowels = /[aƒÖeƒôiouy√≥]/g; // rough
      const m = t.match(vowels);
      return Math.max(1, (m ? m.length : 0));
    }

    function computeCaptureWindowMs(text) {
      const syll = estimateSyllablesPL(text);
      const base = 900;
      const per  = 220;
      const min  = 1400;
      const max  = 3200;
      return Math.max(min, Math.min(max, base + per * syll));
    }

    // Normalise for lexical comparison (ignore case, accents, punctuation)
    function normLexicalPL(text) {
      return String(text || "")
        .toLowerCase()
        .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
        .replace(/[^a-zƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈º0-9]+/g, "");
    }

    function computeStrictScore(paJson, base, refText, voicedMs, diff) {
      // Base metrics from SDK
      let acc = (base && typeof base.acc === "number") ? base.acc : 0;
      let flu = (base && typeof base.flu === "number") ? base.flu : 0;
      let comp = (base && typeof base.comp === "number") ? base.comp : 0;
      let wordErrFrac = 0;
      let lexicalOk = false;

      if (paJson) {
        const top = (paJson.NBest && paJson.NBest[0]) ? paJson.NBest[0] : null;
        const pa  = (top && top.PronunciationAssessment) ? top.PronunciationAssessment : paJson.PronunciationAssessment;
        if (pa) {
          acc  = Math.round(Number(pa.AccuracyScore)     || acc);
          flu  = Math.round(Number(pa.FluencyScore)      || flu);
          comp = Math.round(Number(pa.CompletenessScore) || comp);
        }

        const words = (top && top.Words) ? top.Words : (paJson.Words || []);
        const refCount = Math.max(1, String(refText || "").trim().split(/\s+/).length);
        let errs = 0;
        for (let i = 0; i < words.length; i++) {
          const w = words[i];
          const et = (w && w.PronunciationAssessment) ? w.PronunciationAssessment.ErrorType : null;
          if (et && et !== "None") errs++;
        }
        wordErrFrac = Math.max(0, Math.min(1, errs / refCount));

        // Lexical correctness from NBest
        try {
          const hypRaw  = (top && (top.Lexical || top.Display)) || paJson.Lexical || paJson.Display || "";
          const refNorm = normLexicalPL(refText);
          const hypNorm = normLexicalPL(hypRaw);
          if (refNorm && hypNorm && refNorm === hypNorm) lexicalOk = true;
        } catch (_e) {}
      }

      // Timing expectations
      const syll = estimateSyllablesPL(refText);
      const targetMs = Math.max(320, Math.min(1600, 280 + 110 * syll));
      const needed   = 0.85 * targetMs;
      const baseEnergyF = Math.max(0.4, Math.min(1, (voicedMs || 0) / needed));
      const baseErrF    = 1 - 0.65 * wordErrFrac;

      // Difficulty-dependent penalties
      let energyF = baseEnergyF;
      let errF    = baseErrF;
      const d = diff || "normal";

      if (d === "easy") {
        // No penalties in "easy" mode
        energyF = 1;
        errF    = 1;
      } else if (d === "hard") {
        // Slightly harsher than original
        energyF = baseEnergyF;
        errF    = 1 - 0.80 * wordErrFrac;
      } else {
        // "normal": softer than original, still penalises
        energyF = 0.75 + 0.25 * baseEnergyF;   // in [0.75, 1]
        errF    = 1 - 0.35 * wordErrFrac;      // gentler than 0.65
      }

      const factor = energyF * errF;

      // Penalise each component so breakdown matches final score
      let accAdj = Math.round(acc * factor);
      let fluAdj = Math.round(flu * factor);
      let compAdj = Math.round(comp * factor);

      accAdj  = Math.max(0, Math.min(100, accAdj));
      fluAdj  = Math.max(0, Math.min(100, fluAdj));
      compAdj = Math.max(0, Math.min(100, compAdj));

      // Weighted blend
      let strict = Math.round(0.55 * accAdj + 0.25 * fluAdj + 0.20 * compAdj);
      strict = Math.max(0, Math.min(100, strict));

      return {
        strict: strict,
        acc: accAdj,
        flu: fluAdj,
        comp: compAdj,
        wordErrFrac: wordErrFrac,
        energyF: energyF,
        lexicalOk: lexicalOk
      };
    }

    function extractMetrics(result, SDK) {
      // Try official PA result object first
      try {
        const pa = SDK.PronunciationAssessmentResult.fromResult(result);
        if (pa) return {
          acc: Math.round(pa.accuracyScore || 0),
          flu: Math.round(pa.fluencyScore || 0),
          comp: Math.round(pa.completenessScore || 0)
        };
      } catch(_e) {}
      // Fallback rough zeros; JSON path will fill
      return { acc: 0, flu: 0, comp: 0 };
    }

    async function assessCapture(referenceText, targetEl) {
      const ref = (referenceText || "").trim();
      const empty = { score: 0, acc: 0, flu: 0, comp: 0, lexicalMatch: false };

      if (!window.SpeechSDK) {
        targetEl.textContent = "‚ö†Ô∏è SDK not loaded.";
        return empty;
      }
      if (!ref) {
        targetEl.textContent = "‚ö†Ô∏è No reference text.";
        return empty;
      }

      // Offline ‚Üí no scoring, but user can still listen & repeat
      if (!navigator.onLine) {
        targetEl.textContent = "üì¥ Offline: scoring needs internet, but you can still listen and repeat.";
        return empty;
      }

      targetEl.textContent = "üé§ Recording‚Ä¶";
      const dynMax = computeCaptureWindowMs(ref);
      const rec = await recordBlobVAD(dynMax);
      const tok = await fetchToken();
      const token = tok.token;
      const region = tok.region;
      if (!token || !region) {
        targetEl.textContent = "‚ö†Ô∏è Speech service unavailable. Try again later.";
        return empty;
      }

      // Prepare PCM (and WAV in debug)
      const pcm = await blobToPCM16Mono(rec.blob, 16000);
      if (DEBUG) {
        try {
          const wav = pcmToWavBlob(pcm, 16000);
          const url = URL.createObjectURL(wav);
          dlWav.href = url;
          dlWav.style.display = "inline-flex";
        } catch(_e) {}
      }

      const SDK = window.SpeechSDK;
      const speechConfig = SDK.SpeechConfig.fromAuthorizationToken(token, region);
      speechConfig.speechRecognitionLanguage = "pl-PL";
      speechConfig.outputFormat = SDK.OutputFormat.Detailed;
      speechConfig.setProperty(SDK.PropertyId.SpeechServiceResponse_RequestDetailedResultTrueFalse, "true");
      speechConfig.setProperty(SDK.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "false");

      // Push stream 16k/16-bit/mono
      const format = SDK.AudioStreamFormat.getWaveFormatPCM(16000, 16, 1);
      const push = SDK.AudioInputStream.createPushStream(format);
      push.write(new Uint8Array(pcm.buffer));
      push.close();
      const audioConfig = SDK.AudioConfig.fromStreamInput(push);

      const recognizer = new SDK.SpeechRecognizer(speechConfig, audioConfig);
      const paCfg = new SDK.PronunciationAssessmentConfig(
        ref,
        SDK.PronunciationAssessmentGradingSystem.HundredMark,
        SDK.PronunciationAssessmentGranularity.Phoneme,
        true // enable miscue (insertions/deletions)
      );
      paCfg.applyTo(recognizer);
      try {
        const pl = SDK.PhraseListGrammar.fromRecognizer(recognizer);
        if (pl) pl.add(ref);
      } catch(_e) {}

      targetEl.textContent = "üß† Scoring‚Ä¶";

      const result = await new Promise(function(resolve, reject) {
        try { recognizer.recognizeOnceAsync(resolve, reject); } catch(e) { reject(e); }
      }).catch(function(e) {
        logDbg('recognizeOnce(push) error', e && e.message ? e.message : e);
        return null;
      });

      try { recognizer.close(); } catch(_e) {}

      if (!result) {
        targetEl.textContent = "‚ö†Ô∏è Speech error";
        return empty;
      }

      // Debug dump
      try {
        logDbg('reason', result.reason);
        const SDKR = window.SpeechSDK;
        if (result.reason === SDKR.ResultReason.Canceled) {
          const c = SDKR.CancellationDetails.fromResult(result);
          logDbg('canceled', c && c.reason, c && c.errorCode, c && c.errorDetails);
        }
        if (result.reason === SDKR.ResultReason.NoMatch) {
          const d = SDKR.NoMatchDetails.fromResult(result);
          logDbg('noMatch', d && d.reason);
        }
        const raw = (result.properties && result.properties.getProperty)
          ? result.properties.getProperty(SDK.PropertyId.SpeechServiceResponse_JsonResult)
          : null;
        const rawJson = raw || result.privPronunciationAssessmentJson || result.privJson;
        if (rawJson) {
          try { logRaw(JSON.parse(rawJson)); } catch(_e) { logRaw(rawJson); }
        }
      } catch(_e) {}

      const base = extractMetrics(result, SDK);
      const paJson = extractPAJson(result, SDK);
      const metrics = computeStrictScore(paJson, base, ref, rec.voicedMs, difficulty);

      return {
        score: metrics.strict || 0,
        acc: metrics.acc,
        flu: metrics.flu,
        comp: metrics.comp,
        lexicalMatch: !!metrics.lexicalOk
      };
    }

    async function assessLive(referenceText, targetEl) {
      const ref = (referenceText || "").trim();
      const empty = { score: 0, acc: 0, flu: 0, comp: 0, lexicalMatch: false };

      if (!window.SpeechSDK) {
        targetEl.textContent = "‚ö†Ô∏è SDK not loaded.";
        return empty;
      }
      if (!ref) {
        targetEl.textContent = "‚ö†Ô∏è No reference text.";
        return empty;
      }

      if (!navigator.onLine) {
        targetEl.textContent = "üì¥ Offline: scoring needs internet.";
        return empty;
      }

      targetEl.textContent = "üé§ Preparing‚Ä¶";
      // Tiny warmup for Safari
      try {
        const s = await navigator.mediaDevices.getUserMedia({ audio: true });
        s.getTracks().forEach(function(t) { t.stop(); });
      } catch(_e) {}

      const tok = await fetchToken();
      const token = tok.token;
      const region = tok.region;
      if (!token || !region) {
        targetEl.textContent = "‚ö†Ô∏è Token/region issue";
        return empty;
      }

      const SDK = window.SpeechSDK;
      const speechConfig = SDK.SpeechConfig.fromAuthorizationToken(token, region);
      speechConfig.speechRecognitionLanguage = "pl-PL";
      speechConfig.outputFormat = SDK.OutputFormat.Detailed;
      speechConfig.setProperty(SDK.PropertyId.SpeechServiceResponse_RequestDetailedResultTrueFalse, "true");
      speechConfig.setProperty(SDK.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "false");
      // More forgiving timeouts so users can think + finish
      speechConfig.setProperty(SDK.PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs, "2600");
      speechConfig.setProperty(SDK.PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs, "800");

      const audioConfig = SDK.AudioConfig.fromDefaultMicrophoneInput();
      const recognizer = new SDK.SpeechRecognizer(speechConfig, audioConfig);

      const paCfg = new SDK.PronunciationAssessmentConfig(
        ref,
        SDK.PronunciationAssessmentGradingSystem.HundredMark,
        SDK.PronunciationAssessmentGranularity.Phoneme,
        true
      );
      paCfg.applyTo(recognizer);
      try {
        const pl = SDK.PhraseListGrammar.fromRecognizer(recognizer);
        if (pl) pl.add(ref);
      } catch(_e) {}

      targetEl.textContent = "üéô Listening‚Ä¶";

      const result = await new Promise(function(resolve, reject) {
        try { recognizer.recognizeOnceAsync(resolve, reject); } catch(e) { reject(e); }
      }).catch(function(e) {
        logDbg('recognizeOnce(live) error', e && e.message ? e.message : e);
        return null;
      });

      try { recognizer.close(); } catch(_e) {}

      if (!result) {
        targetEl.textContent = "‚ö†Ô∏è Speech error";
        return empty;
      }

      const base = extractMetrics(result, SDK);
      const paJson = extractPAJson(result, SDK);
      // Live path: approximate voiced duration
      const syll = estimateSyllablesPL(ref);
      const approxVoiced = Math.max(320, Math.min(1600, 280 + 110 * syll)) * 0.7;
      const metrics = computeStrictScore(paJson, base, ref, approxVoiced, difficulty);

      return {
        score: metrics.strict || 0,
        acc: metrics.acc,
        flu: metrics.flu,
        comp: metrics.comp,
        lexicalMatch: !!metrics.lexicalOk
      };
    }

    // ---------- UI wiring ----------
    window.addEventListener("DOMContentLoaded", async function() {
      // Prefetch token & manifest
      prefetchToken().catch(function(){});
      try {
        if (window.AudioPaths) r2Manifest = await AudioPaths.fetchManifest(setName);
      } catch(_e) {
        r2Manifest = null;
      }
      primeAudio(0);
      primeAudio(1);

      // Offline audio controls (Flashcards)
      const offlineBtn = document.getElementById('offlineBtn');
      const offlineRemoveBtn = document.getElementById('offlineRemoveBtn');
      const offlineStatus = document.getElementById('offlineStatus');

      let swReg = null;
      if (offlineBtn && offlineStatus) {
        // Only try SW where it's allowed: https or localhost
        if ('serviceWorker' in navigator &&
            (location.protocol === 'https:' ||
             location.hostname === 'localhost' ||
             location.hostname === '127.0.0.1')) {
          swReg = await ensureSW();
        }

        if (!swReg) {
          offlineBtn.style.display = 'none';
          offlineRemoveBtn.style.display = 'none';
          offlineStatus.textContent = 'Offline download is not available here, but you can still listen while online.';
        } else {
          offlineStatus.textContent = 'Tap Download to make this set available offline.';
        }

        navigator.serviceWorker && navigator.serviceWorker.addEventListener('message', function(ev) {
          const d = ev.data || {};
          if (d.type === 'CACHE_PROGRESS') {
            offlineStatus.textContent = '‚¨áÔ∏è ' + d.done + ' / ' + d.total + ' files cached‚Ä¶';
          } else if (d.type === 'CACHE_DONE') {
            offlineStatus.textContent = '‚úÖ Available offline';
            offlineRemoveBtn.style.display = 'inline-flex';
          } else if (d.type === 'UNCACHE_DONE') {
            offlineStatus.textContent = 'üóë Removed offline copy';
            offlineRemoveBtn.style.display = 'none';
          } else if (d.type === 'CACHE_ERROR') {
            offlineStatus.textContent = '‚ùå Offline failed';
          }
        });

        offlineBtn.addEventListener('click', async function() {
          if (!swReg || !swReg.active) {
            offlineStatus.textContent = '‚ùå Offline not available.';
            return;
          }
          offlineStatus.textContent = '‚¨áÔ∏è Downloading‚Ä¶';
          swReg.active.postMessage({ type: 'CACHE_SET', cache: 'flashcards-' + setName, urls: allAudioUrls() });
        });

        offlineRemoveBtn.addEventListener('click', async function() {
          if (!swReg || !swReg.active) return;
          swReg.active.postMessage({ type: 'UNCACHE_SET', cache: 'flashcards-' + setName });
        });
      }

      // Debug SDK version
      try { logDbg('SDK version?', window.SpeechSDK && window.SpeechSDK.Version ? window.SpeechSDK.Version : 'unknown'); } catch(_e) {}

      renderCard();

      // Flip on tap (ignore buttons/result)
      document.getElementById("cardContainer").addEventListener("click", function(e) {
        if (e.target.closest("button") || e.target.classList.contains("result")) return;
        document.getElementById("cardContainer").classList.toggle("flipped");
        hasFlippedCurrent = true;
      });

      // Front: Say it (capture-first by default)
      const sayBtn = document.getElementById("btnSayFront");
      const frontRes = document.getElementById("frontResult");
      const getRef = function() {
        return (cards[currentIndex] && cards[currentIndex].phrase) || "";
      };

      sayBtn.addEventListener("click", async function(e) {
        e.stopPropagation();
        const ref = getRef();
        if (!ref.trim()) {
          frontRes.textContent = "‚ö†Ô∏è No reference text.";
          return;
        }
        sayBtn.disabled = true;

        const res = CAPTURE_MODE ? await assessCapture(ref, frontRes) : await assessLive(ref, frontRes);
        const score = (res && typeof res.score === "number" && isFinite(res.score)) ? res.score : 0;
        const lexical = !!(res && res.lexicalMatch);

        // --- Lexical recall UI ---
        if (lexical) {
          const phrase = (cards[currentIndex] && cards[currentIndex].phrase) || ref;
          frontRes.innerHTML =
            "‚úÖ " + phrase +
            "<br><span class=\"muted\">Pronunciation rating: " + score + "%</span>";
        } else if (score > 0) {
          frontRes.textContent = "Pronunciation rating: " + score + "% ‚Äî try again.";
        } else {
          // keep whatever message assessCapture/assessLive wrote (offline / error)
        }

        // --- Tracker bookkeeping ---
        tracker.attempts++;
        if (!tracker.per[currentIndex]) {
          tracker.per[currentIndex] = {
            tries: 0,
            best: 0,
            lexicalCorrect: false,
            got100BeforeFlip: false
          };
        }
        const r = tracker.per[currentIndex];
        r.tries++;

        if (isFinite(score)) {
          r.best = Math.max(r.best || 0, score);
          // ‚ÄúPerfect pronunciation before flip‚Äù tracker
          if (!hasFlippedCurrent && score === 100 && !r.got100BeforeFlip) {
            r.got100BeforeFlip = true;
            tracker.perfectNoFlipCount++;
          }
        }
        // Main flashcard correctness: said the right word before seeing the back
        if (!hasFlippedCurrent && lexical) {
          r.lexicalCorrect = true;
        }

        sayBtn.disabled = false;
      });

      // Back: Play (preloaded)
      document.getElementById("btnPlay").addEventListener("click", function(e) {
        e.stopPropagation();
        let a = audioCache.get(currentIndex);
        if (!a) {
          primeAudio(currentIndex);
          a = audioCache.get(currentIndex);
        }
        if (a) {
          try { a.currentTime = 0; } catch(_e) {}
          a.play().catch(function(err) {
            logDbg('audio play err', err && err.message ? err.message : err);
          });
        }
      });

      // Prev / Next / Finish
      document.getElementById("prevBtn").addEventListener("click", function() {
        if (currentIndex > 0) {
          currentIndex--;
          renderCard(); // ensures flipped -> front
        }
      });

      document.getElementById("nextBtn").addEventListener("click", async function() {
        if (currentIndex < cards.length - 1) {
          currentIndex++;
          renderCard(); // ensures flipped -> front
        } else {

          // FINISH
          const totalCards = Math.max(1, cards.length);
          const perStats   = Object.values(tracker.per || {});

          let n100 = 0, n70_99 = 0, nBelow = 0;
          let sumBest = 0, countBest = 0;
          let lexicalCorrectCount = 0;

          for (let i = 0; i < perStats.length; i++) {
            const r = perStats[i];
            if (!r) continue;
            if (r.lexicalCorrect) lexicalCorrectCount++;
            const best = Number(r.best || 0);
            if (!isFinite(best)) continue;
            sumBest += best;
            countBest += 1;

            if (best >= 100)       n100++;
            else if (best >= 70)  n70_99++;
            else                  nBelow++;
          }

          const avgCardScore = countBest > 0 ? (sumBest / countBest) : 0;

          // For flashcards, main score = lexical recall before flipping the card
          const correct  = lexicalCorrectCount;
          const scorePct = Math.round((correct / totalCards) * 100);

          // Cache per-set last result (useful for older per-set summaries)
          try {
            localStorage.setItem(
              "lp_last_result_" + setName,
              JSON.stringify({
                set: setName,
                mode: "flashcards",
                score: scorePct,
                attempts: tracker.attempts,
                total: totalCards,
                n100: n100,
                n70_99: n70_99,
                nBelow: nBelow,
                avg_card_score: avgCardScore,
                perfect_before_flip: tracker.perfectNoFlipCount
              })
            );
          } catch(_e) {}

          // Also cache a GLOBAL lastResult so docs/summary.html can drive the finish UI
          try {
            sessionStorage.setItem(
              "lp.lastResult",
              JSON.stringify({
                set: setName,
                mode: "flashcards",
                score: scorePct,
                attempts: tracker.attempts,
                details: {
                  total: totalCards,
                  n100: n100,
                  n70_99: n70_99,
                  nBelow: nBelow,
                  avg_card_score: avgCardScore,
                  per: tracker.per,
                  perfect_before_flip: tracker.perfectNoFlipCount
                },
                ts: Date.now()
              })
            );
          } catch(_e) {}

          // Helper for root summary URL (GitHub Pages vs Flask)
          function _repoBase() {
            if (/\.github\.io$/i.test(location.hostname)) {
              const parts = location.pathname.split("/").filter(Boolean);
              return "/" + (parts[0] || "LearnPolish");
            }
            return "";
          }

          let awarded = null;
          try {
            const resp = await api.fetch("/api/submit_score", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                set_name: setName,
                mode: "flashcards",
                score: scorePct,
                attempts: tracker.attempts,
                // Gold is fully computed server-side now (first-time, per-card, weekly perfect)
                details: {
                  per: tracker.per,
                  total: totalCards,
                  n100: n100,
                  n70_99: n70_99,
                  nBelow: nBelow,
                  avg_card_score: avgCardScore,
                  perfect_before_flip: tracker.perfectNoFlipCount,
                  difficulty: difficulty,
                  pass_threshold: currentPassThreshold()
                }
              })
            });
            if (resp.ok) {
              const js = await resp.json();
              if (js && js.details && js.details.points_awarded != null) {
                awarded = Number(js.details.points_awarded);
              }
            }
          } catch(_e) {}

          try { localStorage.removeItem("lp_last"); } catch(_e) {}

          const base = _repoBase();
          const params = new URLSearchParams({
            set: setName,
            mode: "flashcards",
            score: String(scorePct)
          });
          if (awarded != null && !Number.isNaN(awarded)) {
            params.set("awarded", String(awarded));
          }

          window.location.href = base + "/summary.html?" + params.toString();

        }
      });
    });

    function goHome() { window.location.href = "index.html"; }
  </script>
</body>
</html>
