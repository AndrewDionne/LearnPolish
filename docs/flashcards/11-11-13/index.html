<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>11-11-13 ‚Ä¢ Learn</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/svg+xml" href="../../static/brand.svg" />
  <style>
    body { font-family: -apple-system,BlinkMacSystemFont, sans-serif; margin:0; padding:20px; background:#f8f9fa; display:flex; flex-direction:column; align-items:center; min-height:100vh; }
    h1 { font-size:1.5em; margin:0 0 8px; position:relative; width:100%; text-align:center; }
    .home-btn { position:absolute; right:0; top:0; font-size:1.4em; background:none; border:none; cursor:pointer; }

    .hint { color:#5a6472; font-size:.9em; margin-bottom:8px; }

    .card { width:90%; max-width:360px; height:260px; perspective:1000px; margin:12px auto; }
    .card-inner {
      width:100%; height:100%; position:relative; transition:transform .6s; transform-style:preserve-3d;
      cursor:pointer; box-shadow:0 4px 10px rgba(0,0,0,.1); display:flex; justify-content:center; align-items:center; border-radius:12px;
    }
    .card.flipped .card-inner { transform: rotateY(180deg); }
    .side { position:absolute; width:100%; height:100%; border-radius:12px; padding:20px; backface-visibility:hidden; display:flex; flex-direction:column; justify-content:center; align-items:center; text-align:center; }
    .front { background:#fff; }
    .back  { background:#e9ecef; transform:rotateY(180deg); }

    .cue { font-size:1.1em; margin-bottom:12px; }
    .answer-phrase { font-weight:700; font-size:1.2em; }
    .answer-pron { font-style:italic; margin-top:4px; }

    .actions { display:flex; gap:8px; margin-top:16px; align-items:center; }
    .btn-small { padding:10px 14px; font-size:1em; background:#2d6cdf; color:#fff; border:none; border-radius:10px; cursor:pointer; }
    .btn-green { background:#28a745; }

    .result { margin-top:8px; font-size:.95em; min-height:1.2em; }

    .meter { width:110px; height:8px; border-radius:6px; background:#e6e6ef; overflow:hidden; }
    .meter > .bar { height:100%; width:0%; background:#2d6cdf; transition:width .05s linear; }

    .nav-buttons { display:flex; gap:12px; margin-top:16px; }
    .nav-button { padding:10px 14px; font-size:1em; background:#007bff; color:#fff; border:none; border-radius:10px; min-width:110px; cursor:pointer; }
    .nav-button:disabled { background:#aaa; cursor:default; }

    /* Debug overlay (enable with ?debug=1) */
    #dbg { display:none; position:fixed; bottom:8px; left:8px; right:8px; max-height:42vh; overflow:auto;
           background:#000; color:#0f0; padding:8px 10px; border-radius:10px; font-family:ui-monospace, SFMono-Regular, Menlo, monospace; font-size:12px; white-space:pre-wrap; z-index:9999; }
    #dbg .row { opacity:.95; }
    #dbg .raw { color:#9ef; }
  </style>
</head>
<body>
  <h1>11-11-13 ‚Ä¢ Learn <button class="home-btn" onclick="goHome()">üè†</button></h1>
  <div class="hint" id="speakHint">Hold the button and speak clearly.</div>

  <div class="card" id="cardContainer" aria-live="polite">
    <div class="card-inner" id="cardInner">
      <div class="side front" id="frontSide">
        <div class="cue" id="frontCue"></div>
        <div class="actions">
          <button class="btn-small" id="btnSayFront" title="Press & hold to speak">üé§ Say it in Polish</button>
          <div class="meter" title="Mic level"><div id="lvl" class="bar"></div></div>
        </div>
        <div class="result" id="frontResult"></div>
      </div>
      <div class="side back" id="backSide">
        <div class="answer-phrase" id="answerPhrase"></div>
        <div class="answer-pron" id="answerPron"></div>
        <div class="actions">
          <button class="btn-small btn-green" id="btnPlay">üîä Play</button>
        </div>
        <div class="result" id="backResult"></div>
      </div>
    </div>
  </div>

  <div class="nav-buttons">
    <button id="prevBtn" class="nav-button">Previous</button>
    <button id="nextBtn" class="nav-button">Next</button>
  </div>

  <div id="dbg"></div>

  <!-- Scripts -->
  <script src="../../static/js/app-config.js"></script>
  <script src="../../static/js/api.js"></script>
  <script src="../../static/js/session_state.js"></script>
  <script src="../../static/js/audio-paths.js"></script>
  <!-- Azure Speech SDK -->
  <script src="https://aka.ms/csspeech/jsbrowserpackageraw"></script>

  <script>
    // --- Data & state ---
    const cards = [{"phrase": "Cze≈õƒá", "meaning": "Hello", "pronunciation": "cheshch", "audio_file": "0_Czesc.mp3"}, {"phrase": "Dziƒôkujƒô", "meaning": "Thank you", "pronunciation": "jen-koo-yeh", "audio_file": "1_Dziekuje.mp3"}];
    const setName = "11-11-13";
    const mode = "flashcards";
    let currentIndex = 0;

    let r2Manifest = null;                      // Optional CDN manifest
    const audioCache = new Map();               // index -> HTMLAudioElement

    // Scoring + points
    const PASS = 75;
    const tracker = {
      attempts: 0,
      per: {},               // per[idx] = { tries, best, got100BeforeFlip: boolean }
      perfectNoFlipCount: 0,
    };
    let hasFlippedCurrent = false;

    // Debug overlay
    const DEBUG = new URL(location.href).searchParams.get('debug') === '1';
    const dbgEl = document.getElementById('dbg');
    if (DEBUG) dbgEl.style.display = 'block';
    function logDbg(...a) {
      if (!DEBUG) return;
      const line = document.createElement('div');
      line.className = 'row';
      line.textContent = a.map(x => (typeof x === 'string' ? x : JSON.stringify(x))).join(' ');
      dbgEl.appendChild(line);
      dbgEl.scrollTop = dbgEl.scrollHeight;
      try { console.debug('[FC]', ...a); } catch(_){
      }
    }
    function logRaw(j) {
      if (!DEBUG) return;
      const line = document.createElement('div');
      line.className = 'row raw';
      line.textContent = (typeof j === 'string') ? j : JSON.stringify(j);
      dbgEl.appendChild(line);
      dbgEl.scrollTop = dbgEl.scrollHeight;
    }

    // Platform detection
    const ua = navigator.userAgent || '';
    const IS_IOS = /iPad|iPhone|iPod/.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    const IS_SAFARI = /^((?!chrome|android).)*safari/i.test(ua);

    // --- Audio meter ---
    const lvlEl = document.getElementById('lvl');
    function setLevel(v) {  // v: 0..1
      const pct = Math.max(0, Math.min(1, v)) * 100;
      lvlEl.style.width = pct.toFixed(0) + '%';
    }

    // --- WAV capture (Web Audio) ---
    let mediaStream = null;
    let audioCtx = null;
    let srcNode = null;
    let procNode = null;
    let buffers = [];
    let captureSampleRate = 48000;  // will be set from AudioContext
    let capturing = false;

    async function startCapture() {
      // Request mic each time (stay on the safe side for iOS)
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const Ctx = window.AudioContext || window.webkitAudioContext;
      audioCtx = new Ctx();
      await audioCtx.resume();
      captureSampleRate = audioCtx.sampleRate;

      srcNode = audioCtx.createMediaStreamSource(mediaStream);
      procNode = audioCtx.createScriptProcessor(2048, 1, 1);

      buffers = [];
      capturing = true;

      procNode.onaudioprocess = (e) => {
        if (!capturing) return;
        const chan = e.inputBuffer.getChannelData(0); // mono
        // copy out (Float32Array is reused by the browser)
        buffers.push(new Float32Array(chan));
        // meter (RMS)
        let sum = 0;
        for (let i = 0; i < chan.length; i++) sum += chan[i] * chan[i];
        const rms = Math.sqrt(sum / chan.length);
        setLevel(Math.min(1, rms * 3)); // a bit of gain
      };

      srcNode.connect(procNode);
      procNode.connect(audioCtx.destination); // required for some browsers, effectively silent
    }

    function stopCaptureAndEncodeWav() {
      return new Promise((resolve) => {
        try {
          capturing = false;
          if (procNode) procNode.disconnect();
          if (srcNode) srcNode.disconnect();
          try { audioCtx && audioCtx.close(); } catch(_){
          }
          try { mediaStream && mediaStream.getTracks().forEach(t => t.stop()); } catch(_){
          }
          setLevel(0);
        } finally {
          resolve(encodeWav(buffers, captureSampleRate));
        }
      });
    }

    function interleaveFloat32(buffers) {
      // buffers: array of Float32Array blocks, mono
      if (!buffers.length) return new Float32Array(0);
      let len = 0;
      for (const b of buffers) len += b.length;
      const out = new Float32Array(len);
      let off = 0;
      for (const b of buffers) { out.set(b, off); off += b.length; }
      return out;
    }

    function floatTo16BitPCM(float32) {
      const out = new DataView(new ArrayBuffer(float32.length * 2));
      let offset = 0;
      for (let i = 0; i < float32.length; i++, offset += 2) {
        let s = Math.max(-1, Math.min(1, float32[i]));
        s = s < 0 ? s * 0x8000 : s * 0x7FFF;
        out.setInt16(offset, s, true);
      }
      return out;
    }

    function writeString(view, offset, str) {
      for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
    }

    function encodeWav(bufferBlocks, sampleRate) {
      const samples = interleaveFloat32(bufferBlocks);
      const pcm = floatTo16BitPCM(samples);
      const bytesPerSample = 2;
      const blockAlign = 1 * bytesPerSample;
      const byteRate = sampleRate * blockAlign;

      const header = new DataView(new ArrayBuffer(44));
      writeString(header, 0, 'RIFF');
      header.setUint32(4, 36 + pcm.byteLength, true);
      writeString(header, 8, 'WAVE');
      writeString(header, 12, 'fmt ');
      header.setUint32(16, 16, true);             // PCM
      header.setUint16(20, 1, true);              // PCM format
      header.setUint16(22, 1, true);              // mono
      header.setUint32(24, sampleRate, true);
      header.setUint32(28, byteRate, true);
      header.setUint16(32, blockAlign, true);
      header.setUint16(34, bytesPerSample * 8, true); // bits per sample
      writeString(header, 36, 'data');
      header.setUint32(40, pcm.byteLength, true);

      const wavBuffer = new Uint8Array(44 + pcm.byteLength);
      wavBuffer.set(new Uint8Array(header.buffer), 0);
      wavBuffer.set(new Uint8Array(pcm.buffer), 44);
      return new Blob([wavBuffer], { type: 'audio/wav' });
    }

    // Mirror of Python sanitize_filename (for audio file names)
    function sanitizeFilename(text) {
      return (text || "")
        .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
        .replace(/[^a-zA-Z0-9_-]+/g, "_")
        .replace(/^_+|_+$/g, "");
    }

    function localAudioPath(index) {
      const e = cards[index] || {};
      const fn = String(index) + "_" + sanitizeFilename(e.phrase || "") + ".mp3";
      const setEnc = encodeURIComponent(setName);
      const fnEnc  = encodeURIComponent(fn);

      const explicit = e.audio_url || e.audio;
      if (explicit && /^https?:\/\//i.test(explicit)) return explicit;

      return `../../static/${setEnc}/audio/${fnEnc}`;
    }

    function buildAudioSrc(index) {
      let src = localAudioPath(index);
      try {
        if (window.AudioPaths) src = AudioPaths.buildAudioPath(setName, index, cards[index], r2Manifest);
      } catch (_ignore) {
      }
      return src;
    }

    function primeAudio(index) {
      if (index < 0 || index >= cards.length) return;
      if (audioCache.has(index)) return;
      const src = buildAudioSrc(index);
      const a = new Audio();
      a.preload = "auto";
      a.src = src;
      try { a.load(); } catch(_){
      }
      audioCache.set(index, a);
    }

    function resetAndPrimeAround(index) {
      audioCache.clear();
      primeAudio(index);
      primeAudio(index + 1);
    }

    function setNavUI() {
      document.getElementById("prevBtn").disabled = (currentIndex === 0);
      const nextBtn = document.getElementById("nextBtn");
      nextBtn.textContent = (currentIndex < cards.length - 1) ? "Next" : "Finish";
    }

    function renderCard() {
      const e = cards[currentIndex] || {};
      document.getElementById("frontCue").textContent = e.meaning || "";
      document.getElementById("frontResult").textContent = "";
      document.getElementById("answerPhrase").textContent = e.phrase || "";
      document.getElementById("answerPron").textContent   = e.pronunciation || "";
      document.getElementById("backResult").textContent   = "";
      setNavUI();
      hasFlippedCurrent = false;
      resetAndPrimeAround(currentIndex);
    }

    // --- Azure PA on a WAV blob ---
    async function assessWavBlob(wavBlob, referenceText) {
      if (!window.SpeechSDK) throw new Error("sdk_not_loaded");

      const tok = await api.get('/api/speech_token', { noAuth: true });
      const token  = tok && (tok.token || tok.access_token);
      const region = tok && (tok.region || tok.location || tok.regionName);
      if (!token || !region) throw new Error("no_token");

      const SpeechSDK = window.SpeechSDK;
      const speechConfig = SpeechSDK.SpeechConfig.fromAuthorizationToken(token, region);
      speechConfig.speechRecognitionLanguage = "pl-PL";
      speechConfig.outputFormat = SpeechSDK.OutputFormat.Detailed;
      speechConfig.setProperty(SpeechSDK.PropertyId.SpeechServiceResponse_RequestDetailedResultTrueFalse, "true");

      const audioConfig = SpeechSDK.AudioConfig.fromWavFileInput(wavBlob);
      const recognizer = new SpeechSDK.SpeechRecognizer(speechConfig, audioConfig);

      const pa = new SpeechSDK.PronunciationAssessmentConfig(
        referenceText,
        SpeechSDK.PronunciationAssessmentGradingSystem.HundredMark,
        SpeechSDK.PronunciationAssessmentGranularity.Word,
        true // miscue
      );
      pa.applyTo(recognizer);

      return await new Promise((resolve, reject) => {
        try {
          recognizer.recognizeOnceAsync((result) => {
            try { recognizer.close(); } catch(_){
            }
            try {
              const raw = result?.properties?.getProperty(SpeechSDK.PropertyId.SpeechServiceResponse_JsonResult) || result?.privPronunciationAssessmentJson;
              if (raw) logRaw(raw);
              const reason = result?.reason || 0;
              if (reason === SpeechSDK.ResultReason.Canceled) return resolve({ score: 0, reason });
              // parse score
              let score = 0;
              if (raw) {
                const j = JSON.parse(raw);
                score = Math.round(
                  (j?.NBest?.[0]?.PronunciationAssessment?.AccuracyScore) ??
                  (j?.PronunciationAssessment?.AccuracyScore) ?? 0
                );
              }
              resolve({ score, reason });
            } catch (e) {
              resolve({ score: 0, error: String(e) });
            }
          }, (err) => {
            try { recognizer.close(); } catch(_){
            }
            reject(err);
          });
        } catch (e) {
          try { recognizer.close(); } catch(_){
          }
          reject(e);
        }
      });
    }

    // --- Interaction wiring ---
    window.addEventListener("DOMContentLoaded", async function() {
      // Hint line
      document.getElementById('speakHint').textContent =
        (IS_IOS || IS_SAFARI) ? "Hold the button while you speak." : "Click, then speak when prompted.";

      // Try to load R2 manifest (non-blocking)
      try { if (window.AudioPaths) r2Manifest = await AudioPaths.fetchManifest(setName); } catch (_e) { r2Manifest = null; }

      renderCard();

      // Flip on tap (ignore buttons/result)
      document.getElementById("cardContainer").addEventListener("click", (e) => {
        if (e.target.closest("button") || e.target.classList.contains("result")) return;
        document.getElementById("cardContainer").classList.toggle("flipped");
        hasFlippedCurrent = true;
      });

      // ---- Front: Say it (capture ‚Üí WAV ‚Üí assess)
      const sayBtn = document.getElementById("btnSayFront");
      const frontRes = document.getElementById("frontResult");

      const getRef = () => (cards[currentIndex] && cards[currentIndex].phrase) || "";

      async function startPress() {
        const ref = getRef();
        if (!ref.trim()) { frontRes.textContent = "‚ö†Ô∏è No reference text."; return; }
        frontRes.textContent = "üé§ Recording‚Ä¶";
        try {
          await startCapture();
        } catch (e) {
          frontRes.textContent = "‚ö†Ô∏è Mic error";
        }
      }

      async function endPress() {
        try {
          const wav = await stopCaptureAndEncodeWav();
          frontRes.textContent = "‚è≥ Scoring‚Ä¶";
          const res = await assessWavBlob(wav, getRef());
          const s = Number(res?.score) || 0;
          frontRes.textContent = s ? `‚úÖ ${s}%` : "‚ö†Ô∏è No score";

          // record stats
          tracker.attempts++;
          if (!tracker.per[currentIndex]) tracker.per[currentIndex] = { tries: 0, best: 0, got100BeforeFlip: false };
          const r = tracker.per[currentIndex];
          r.tries++;
          r.best = Math.max(r.best || 0, s);
          if (!hasFlippedCurrent && s === 100 && !r.got100BeforeFlip) {
            r.got100BeforeFlip = true;
            tracker.perfectNoFlipCount++;
          }
        } catch (e) {
          frontRes.textContent = "‚ö†Ô∏è Speech error";
        }
      }

      if (IS_IOS || IS_SAFARI) {
        // Hold to speak
        sayBtn.addEventListener('pointerdown', (ev) => { ev.preventDefault(); startPress(); });
        sayBtn.addEventListener('pointerup',   (ev) => { ev.preventDefault(); endPress(); });
        sayBtn.addEventListener('pointerleave',(ev) => { ev.preventDefault(); endPress(); });
        // Touch fallback
        sayBtn.addEventListener('touchstart', (ev) => { ev.preventDefault(); startPress(); }, {passive:false});
        sayBtn.addEventListener('touchend',   (ev) => { ev.preventDefault(); endPress(); },   {passive:false});
      } else {
        // Single tap: short timed window (‚âà2.2s)
        sayBtn.addEventListener("click", async (e) => {
          e.stopPropagation();
          await startPress();
          await new Promise(r => setTimeout(r, 2200));
          await endPress();
        });
      }

      // ---- Back: Play (preloaded)
      document.getElementById("btnPlay").addEventListener("click", async (e) => {
        e.stopPropagation();
        let a = audioCache.get(currentIndex);
        if (!a) { primeAudio(currentIndex); a = audioCache.get(currentIndex); }
        if (a) {
          try { a.currentTime = 0; } catch(_){
          }
          a.play().catch(()=>{});
        }
      });

      // Prev / Next / Finish
      document.getElementById("prevBtn").addEventListener("click", () => {
        if (currentIndex > 0) {
          currentIndex--;
          renderCard();
          if (window.SessionSync) SessionSync.save({ setName, mode, progress: { index: currentIndex, per: tracker.per } });
        }
      });

      document.getElementById("nextBtn").addEventListener("click", async () => {
        if (currentIndex < cards.length - 1) {
          currentIndex++;
          renderCard();
          if (window.SessionSync) SessionSync.save({ setName, mode, progress: { index: currentIndex, per: tracker.per } });
        } else {
          // FINISH
          const totalCards = Math.max(1, cards.length);
          const correct = Object.values(tracker.per).filter(r => (r?.best || 0) >= PASS).length;
          const scorePct = Math.round((correct / totalCards) * 100);

          let pointsTotal = 10 + tracker.perfectNoFlipCount;
          if (scorePct === 100) pointsTotal = pointsTotal * 2;

          try {
            localStorage.setItem("lp_last_result_" + setName, JSON.stringify({
              score: scorePct,
              attempts: tracker.attempts,
              total: totalCards,
              points_total: pointsTotal,
              perfect_before_flip: tracker.perfectNoFlipCount
            }));
          } catch (_ignore) {
          }

          let awarded = null;
          try {
            const resp = await api.fetch("/api/submit_score", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                set_name: setName,
                mode: "flashcards",
                score: scorePct,
                attempts: tracker.attempts,
                details: {
                  per: tracker.per,
                  total: totalCards,
                  perfect_before_flip: tracker.perfectNoFlipCount,
                  points_total: pointsTotal
                }
              })
            });
            if (resp.ok) {
              const js = await resp.json();
              awarded = (js && js.details && js.details.points_awarded != null)
                ? Number(js.details.points_awarded) : null;
            }
          } catch (_ignore) {
          }

          try { if (window.SessionSync) await SessionSync.complete({ setName, mode }); } catch(_ignore) {
          }
          try { localStorage.removeItem("lp_last"); } catch(_ignore) {
          }
          const q = awarded != null ? ("?awarded=" + encodeURIComponent(awarded)) : "";
          window.location.href = "summary.html" + q;
        }
      });

      // Resume mid-set if ?resume=1
      (async () => {
        const wantResume = new URL(location.href).searchParams.get("resume") === "1";
        if (wantResume && window.SessionSync) {
          await SessionSync.restore({ setName, mode }, (progress) => {
            if (progress && Number.isFinite(progress.index)) {
              currentIndex = Math.max(0, Math.min(cards.length - 1, progress.index));
            }
            if (progress && progress.per) Object.assign(tracker.per, progress.per);
            renderCard();
          });
        }
        try { localStorage.setItem("lp_last", JSON.stringify({ set_name:setName, mode, ts: Date.now() })); } catch(_ignore) {
        }
      })();
    });

    function goHome() { window.location.href = "../../index.html"; }
  </script>

</body>
</html>
