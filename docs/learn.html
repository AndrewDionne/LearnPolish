<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Dual-host <base> (GitHub Pages vs Flask/Render) -->
  <script>
    (function () {
      var isGH = /\.github\.io$/i.test(location.hostname);
      var baseHref = isGH ? '/LearnPolish/' : '/';
      document.write('<base href="' + baseHref + '">');
    })();
  </script>

  <!-- Fonts (optional) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@600;700&family=Manrope:wght@700;800&family=Source+Serif+4:opsz,wght@8..60,400;8..60,600&display=swap" rel="stylesheet">

  <!-- Styles -->
  <link rel="stylesheet" href="static/app.css?v=5">
  <title>Learn • Path to POLISH</title>
</head>

<body
  data-header="Path to Polish"
  data-note-lead="Get ready to Learn!"
  data-note-tail="Scroll your collections to find the right one for you."
  data-note-no-sep
  data-note-tight
  style="
    --logo-size: 48px;
    --banner-font: 'Manrope', -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial;
    --banner-weight: 800;
    --banner-track: .01em;
    --banner-case: none;
    --banner-size: 28px;
    --banner-size-lg: 36px;
    --banner-nudge-x: 10px;

    --note-lead-font: 'Inter', ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    --note-lead-size: 18px;
    --note-lead-weight: 700;
    --note-lead-track: .02em;
    --note-lead-case: none;
    --note-lead-color: var(--text);

    --note-font: 'Source Serif 4', ui-serif, Georgia, 'Times New Roman', serif;
    --note-weight: 400;
  ">
  <!-- Header -->
  <header class="topbar no-nav">
    <div class="row container">
      <div class="header-left">
        <a class="brand" href="index.html" aria-label="Path to Polish — Home">
          <svg class="brand-mark" aria-hidden="true" focusable="false">
            <use href="static/brand.svg#ptp-mark"></use>
          </svg>
          <span id="headerBanner" class="header-banner"></span>
        </a>
      </div>
      <nav class="head-actions">
        <a href="profile.html"  id="profileBtn">Profile</a>
        <a href="login.html"    id="loginLink">Sign In</a>
        <a href="register.html" id="registerLink">Register</a>
        <button id="logoutBtn" style="display:none;">Logout</button>
      </nav>
    </div>
  </header>

  <!-- Page note -->
  <div class="wrap">
    <div id="pageNote" class="page-note"></div>
  </div>

  <!-- Main content -->
  <div class="wrap">
    <div class="toolbar">
      <div class="search-bar">
        <input id="q" type="text" placeholder="Search collections…" />
      </div>

      <div class="seg" role="tablist" aria-label="Mode Filter">
        <button id="f_all"    class="active" aria-pressed="true">All</button>
        <button id="f_learn">Learn</button>
        <button id="f_speak">Speak</button>
        <button id="f_listen">Listen</button>
        <button id="f_read">Read</button>
      </div>
    </div>

    <div class="card" id="learningCard">
      <div class="table-wrap">
        <table id="setsTable">
          <thead>
            <tr>
              <th style="min-width:140px;">Rating</th>
              <th style="min-width:260px;">Collection</th>
              <th style="min-width:170px;">Activity</th>
              <th style="min-width:120px;">Status</th>
            </tr>
          </thead>
          <tbody id="setsBody"></tbody>
        </table>
      </div>
      <div id="emptyMine" class="muted" style="display:none; padding-top:8px;">
        Please sign in to see your learning list.
      </div>
    </div>
  </div>

  <!-- Bottom nav -->
  <nav class="bottom" aria-label="Primary">
    <a href="index.html">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M3 10.5L12 3l9 7.5V21a1 1 0 0 1-1 1h-5v-7H9v7H4a 1 1 0 0 1-1-1v-10.5Z" stroke-width="1.5"/></svg>
      <span>Home</span>
    </a>
    <a href="learn.html" aria-current="page">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M4 6h16M4 12h16M4 18h9" stroke-width="1.5" stroke-linecap="round"/></svg>
      <span>Learn</span>
    </a>
    <a href="manage_sets/index.html">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><rect x="3" y="4" width="18" height="16" rx="2" ry="2" stroke-width="1.5"/><path d="M7 8h10M7 12h10M7 16h7" stroke-width="1.5" stroke-linecap="round"/></svg>
      <span>Library</span>
    </a>
    <a href="dashboard.html">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M4 14h6V4H4v10Zm10 6h6V4h-6v16Z" stroke-width="1.5"/></svg>
      <span>Dashboard</span>
    </a>
    <a href="groups.html">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M12 12a5 5 0 1 0-5-5 5 5 0 0 0 5 5Zm-9 9a9 9 0 0 1 18 0" stroke-width="1.5" stroke-linecap="round"/></svg>
      <span>Groups</span>
    </a>
  </nav>

  <!-- Load runtime config first, then API helpers -->
  <script src="static/js/app-config.js"></script>
  <script src="static/js/audio-paths.js"></script>
  <script src="static/js/flashcards-audio-adapter.js"></script>

  <script src="static/js/api.js"></script>
  <script src="static/js/page-chrome.js" defer></script>

  <script>
  // ---------- Header auth ----------
  (async function wireHeader(){
    const loginLink    = document.getElementById('loginLink');
    const registerLink = document.getElementById('registerLink');
    const logoutBtn    = document.getElementById('logoutBtn');
    let me=null;
    try{ const r=await api.fetch('/api/me'); if(r.ok) me=await r.json(); }catch(_){}
    if(me){
      loginLink && (loginLink.style.display='none');
      registerLink && (registerLink.style.display='none');
      logoutBtn && (logoutBtn.style.display='inline-block');
    }else{
      loginLink && (loginLink.style.display='inline-block');
      registerLink && (registerLink.style.display='inline-block');
      logoutBtn && (logoutBtn.style.display='none');
    }
    logoutBtn?.addEventListener('click', async () => {
      try{ await api.fetch('/api/logout', {method:'POST'});}catch(_){}
      api.clearToken();
      location.href = 'login.html';
    });
  })();

  // ---------- Utilities ----------
  const PASS = 100;
  const dayMs = 86400000;

  function encode(name){ return encodeURIComponent(name||''); }

  function detectTypeByName(name){
    const s = String(name||'');
    if (/\b(read|reading|story|article)\b/i.test(s))   return 'reading';
    if (/\b(listen|listening|audio|podcast)\b/i.test(s)) return 'listening';
    return 'flashcards';
  }

  function pathFor(mode, setName){
    const enc = encode(setName);
    if (mode==='read')    return 'reading/'   + enc + '/';
    if (mode==='listen')  return 'listening/' + enc + '/';
    if (mode==='speak')   return 'practice/'  + enc + '/';
    return 'flashcards/' + enc + '/';
  }

  function starsText(n){
    if (typeof n !== 'number' || isNaN(n)) n = 0;
    n = Math.max(0, Math.min(5, Math.round(n)));
    return '★'.repeat(n) + '☆'.repeat(5-n);
  }

  function timeAgoBucket(iso){
    if(!iso) return '—';
    const d = new Date(iso), now = new Date();
    const diff = (now - d) / dayMs;
    if (diff < 1) return 'today';
    if (diff < 2) return 'yesterday';
    if (diff < 7) return 'this week';
    if (diff < 30) return 'this month';
    return 'long ago';
  }

  function srsStatus(perfectDates){
    const sorted = (perfectDates||[]).map(d=>new Date(d)).sort((a,b)=>b-a);
    const last = sorted[0];
    const first = sorted[sorted.length-1];
    const daysSince = last ? (Date.now() - last.getTime())/dayMs : Infinity;

    let greenDays=1;
    if(sorted.length===1) greenDays=1;
    else if(sorted.length===2) greenDays=2;
    else if(sorted.length===3) greenDays=3;
    else if(sorted.length>=4) greenDays=7;

    if (sorted.length>=5 && first && (Date.now()-first.getTime())/dayMs >= 30) {
      return {label:'Complete', cls:'green', link:false};
    }
    if (daysSince < greenDays)   return {label:'Great', cls:'green',  link:false};
    if (daysSince < greenDays+2) return {label:'Due soon', cls:'blue', link:false};
    return {label:'Repetition due', cls:'red', link:true};
  }

  function buildStatsBySet(scores){
    const map = new Map();
    for(const s of (scores||[])){
      const name = s.set_name || ''; if(!name) continue;
      const rec = map.get(name) || { best:null, trials:0, last_ts:null, perfect_dates:[] };
      const sc = Number(s.score)||0;
      const att = Number(s.attempts)||0;
      const ts = s.timestamp || null;
      rec.best = (rec.best==null) ? sc : Math.max(rec.best, sc);
      rec.trials += att || 1;
      if(ts && (!rec.last_ts || new Date(ts) > new Date(rec.last_ts))) rec.last_ts = ts;
      if(sc>=PASS && ts) rec.perfect_dates.push(ts);
      map.set(name, rec);
    }
    return map;
  }

  // ---------- Data fetchers ----------
  async function fetchMyLibrary(){
    try{
      const r = await api.fetch('/api/my/sets');
      if (r && r.status === 401) return { unauth: true, data: [] };
      if (r && r.ok){
        const arr = await r.json();
        return { unauth:false, data: (arr||[]).map(x => ({ name: x.set_name || x.name || '', modes: x.modes || null, type: x.type || null })) };
      }
    }catch(_){}
    try{
      const r2 = await api.fetch('/api/my_sets');
      if (r2 && r2.ok){
        const arr2 = await r2.json();
        return { unauth:false, data: (arr2||[]).map(x => ({ name: x.set_name || x.name || '' })) };
      }
    }catch(_){}
    return { unauth:false, data: [] };
  }

  async function fetchGlobal(){
    try{
      let r = await api.fetch('/api/global_sets');
      if (r.ok) return await r.json();
    }catch(_){}
    try{
      const r2 = await api.fetch('/api/sets/available');
      if (r2.ok){
        const arr = await r2.json();
        return (arr||[]).map(x => ({ name:x.name, count:x.count, modes:null, type:x.type||null }));
      }
    }catch(_){}
    return [];
  }

  async function fetchMyScores(){
    try{
      const r = await api.fetch('/api/my/scores?limit=2000');
      return r.ok ? await r.json() : [];
    }catch(_){ return []; }
  }

  async function fetchRatingsBatch(names){
    if(!names.length) return {};
    try{
      const r = await api.fetch('/api/sets/ratings/batch', {
        method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ sets: names.slice(0,400) })
      });
      if(!r.ok) return {};
      const arr = await r.json();
      const map = {}; (arr||[]).forEach(x => map[x.set_name] = {avg:x.avg_stars, count:x.count});
      return map;
    }catch(_){ return {}; }
  }

  async function fetchMyRatings(){
    try{
      const r = await api.fetch('/api/my/ratings');
      if(!r.ok) return new Set();
      const arr = await r.json();
      return new Set((arr||[]).map(x => x.set_name));
    }catch(_){ return new Set(); }
  }

  // ---------- Rendering ----------
  let activityModesFor = (name) => {
    const t = detectTypeByName(name);
    if (t==='reading')   return ['read'];
    if (t==='listening') return ['listen'];
    return ['learn','speak'];
  };

  function activityButtons(name){
    const modes = activityModesFor(name);
    return `<span class="acts">${
      modes.map((m, idx) => {
        const label = m==='learn' ? 'Learn' : m==='speak' ? 'Speak' : m==='read' ? 'Read' : 'Listen';
        const primary = idx === 0 ? 'btn-primary' : '';
        return `<a class="btn ${primary}" href="${pathFor(m, name)}">${label}</a>`;
      }).join('')
    }</span>`;
  }

  function statusCell(name, stats){
    if(!stats || (!stats.trials && !stats.last_ts)){
      return `<span class="badge blue">New</span>`;
    }
    const best = (typeof stats.best==='number') ? Math.round(stats.best) : null;
    if (!stats.perfect_dates || stats.perfect_dates.length === 0){
      const label = (best!=null) ? (best + '%') : 'Tried';
      return `<span class="badge blue">${label}</span>`;
    }
    const srs = srsStatus(stats.perfect_dates);
    const href = pathFor(activityModesFor(name)[0], name);
    if (srs.link && srs.label === 'Repetition due'){
      return `<a class="badge red" href="${href}">${srs.label}</a>`;
    }
    const cls = srs.cls === 'green' ? 'green' : (srs.cls === 'red' ? 'red' : 'blue');
    return `<span class="badge ${cls}">${srs.label}</span>`;
  }

  function trFor(row, stats, rating, userHasRated){
    const ratingStars = `<span class="rating">${starsText(rating?.avg)}</span>` +
                        (typeof rating?.count==='number' ? `<span class="muted small"> (${rating.count})</span>` : '');
    const addRating = userHasRated ? '' : `<div class="small"><a href="./manage_sets/">add your rating</a></div>`;
    const last = stats?.last_ts ? timeAgoBucket(stats.last_ts) : '—';
    const best = (typeof stats?.best==='number') ? ` • top ${stats.best}%` : '';
    const trials = (typeof stats?.trials==='number') ? ` • ${stats.trials} trials` : '';

    return `
      <tr>
        <td>${ratingStars}${addRating}</td>
        <td title="${row.name}">
          <strong>${row.name}</strong>
          <span class="muted small">${last}${best}${trials}</span>
        </td>
        <td>${activityButtons(row.name)}</td>
        <td>${statusCell(row.name, stats)}</td>
      </tr>
    `;
  }

  function renderTable(rows, statsMap, ratingsMap, myRatedSet){
    const body = document.getElementById('setsBody');
    body.innerHTML = rows.map(r => trFor(r, statsMap.get(r.name), ratingsMap[r.name], myRatedSet.has(r.name))).join('');
  }

  // Sort by review urgency (SRS + recency) so the most important sets float to the top.
  function urgencyKeyFor(row, statsMap){
    const stats = statsMap.get(row.name);
    const nameKey = (row.name || '').toLowerCase();

    // Brand-new: no attempts, no timestamps
    if (!stats || (!stats.trials && !stats.last_ts)) {
      // Bucket 2 → after “Due soon / Tried”, before “Great / Complete”
      return [2, Number.POSITIVE_INFINITY, nameKey];
    }

    // Tried but never perfect: keep fairly high
    if (!stats.perfect_dates || stats.perfect_dates.length === 0) {
      const tsVal = stats.last_ts ? new Date(stats.last_ts).getTime() : Number.POSITIVE_INFINITY;
      // Bucket 1 → similar priority to “Due soon”
      return [1, tsVal, nameKey];
    }

    // Has perfect runs → use SRS label
    const srs = srsStatus(stats.perfect_dates);
    let bucket;
    switch ((srs && srs.label) || '') {
      case 'Repetition due': bucket = 0; break; // top
      case 'Due soon':       bucket = 1; break;
      case 'Great':          bucket = 3; break;
      case 'Complete':       bucket = 4; break; // bottom
      default:               bucket = 3; break;
    }

    // Within each bucket, older “last_ts” comes first
    const tsVal = stats.last_ts ? new Date(stats.last_ts).getTime() : Number.POSITIVE_INFINITY;
    return [bucket, tsVal, nameKey];
  }

  function sortRowsByUrgency(rows, statsMap){
    return [...rows].sort((a, b) => {
      const ka = urgencyKeyFor(a, statsMap);
      const kb = urgencyKeyFor(b, statsMap);
      if (ka[0] !== kb[0]) return ka[0] - kb[0];     // bucket
      if (ka[1] !== kb[1]) return ka[1] - kb[1];     // timestamp
      if (ka[2] < kb[2]) return -1;                  // name tiebreaker
      if (ka[2] > kb[2]) return 1;
      return 0;
    });
  }

  function applyFilters(list, filterMode, q){
    const QQ = (q||'').trim().toLowerCase();
    return list.filter(m => {
      const okQ = !QQ || (m.name.toLowerCase().includes(QQ));
      if(!okQ) return false;
      if(filterMode==='all') return true;
      const modes = activityModesFor(m.name);
      return modes.includes(filterMode);
    });
  }


  // ---------- Main ----------
  (async function init(){
    const [libRes, globalSetsRes, scoresRes] = await Promise.all([
      fetchMyLibrary(),
      fetchGlobal(),
      fetchMyScores(),
    ]);

    const unauth      = !!(libRes && libRes.unauth);
    const mineRaw     = Array.isArray(libRes?.data) ? libRes.data : [];
    const globalSets  = Array.isArray(globalSetsRes) ? globalSetsRes : [];
    const scores      = Array.isArray(scoresRes) ? scoresRes : [];

    const statsMapLocal = buildStatsBySet(scores || []);

    const combinedModeMap = Object.create(null);
    const modesFromType = (t)=>{
      const tt = String(t || '').toLowerCase();
      if (tt === 'reading'   || tt === 'read')      return ['read'];
      if (tt === 'listening' || tt === 'listen')    return ['listen'];
      if (tt === 'flashcards'|| tt === 'vocab' || tt === 'cards') return ['learn','speak'];
      return null;
    };
    const nameOf = (x)=> (x && (x.name || x.set_name)) || '';

    (globalSets || []).forEach(x=>{
      const n = nameOf(x); if(!n) return;
      if (Array.isArray(x.modes) && x.modes.length) combinedModeMap[n] = x.modes;
      else {
        const mf = modesFromType(x.type); if (mf) combinedModeMap[n] = mf;
      }
    });
    (mineRaw || []).forEach(x=>{
      const n = nameOf(x); if(!n || combinedModeMap[n]) return;
      if (Array.isArray(x.modes) && x.modes.length) combinedModeMap[n] = x.modes;
      else {
        const mf = modesFromType(x.type); if (mf) combinedModeMap[n] = mf;
      }
    });

    activityModesFor = (name)=>{
      const arr = combinedModeMap[name];
      if (Array.isArray(arr) && arr.length) return arr;
      const t = detectTypeByName(name);
      if (t==='reading')   return ['read'];
      if (t==='listening') return ['listen'];
      return ['learn','speak'];
    };

        const mine = mineRaw.map(x => {
      const n = nameOf(x);
      const m = Array.isArray(x.modes) && x.modes.length ? x.modes : (combinedModeMap[n] || null);
      return { name: n, modes: m, type: x.type || null };
    });

    const currentNames = mine.map(r => r.name).slice(0, 400);

    // Ratings are only relevant for authenticated users with at least one set.
    let ratingsMapLocal = {};
    let myRatedSetLocal = new Set();
    if (!unauth && currentNames.length) {
      [ratingsMapLocal, myRatedSetLocal] = await Promise.all([
        fetchRatingsBatch(currentNames),
        fetchMyRatings(),
      ]);
    }

    if (unauth){ const el = document.getElementById('emptyMine'); if (el) el.style.display='block'; }

    const qEl = document.getElementById('q');
    const filterBtns = {
      all:    document.getElementById('f_all'),
      learn:  document.getElementById('f_learn'),
      speak:  document.getElementById('f_speak'),
      listen: document.getElementById('f_listen'),
      read:   document.getElementById('f_read'),
    };
    let filterMode = 'all';

    (function initFilterFromQuery(){
      try{
        var m = (new URLSearchParams(location.search).get('mode') || '').toLowerCase();
        if (m && filterBtns[m]) {
          filterBtns[m].click();
          return;
        }
      }catch(_){}
      filterBtns.all && filterBtns.all.click();
    })();

    function setFilter(key){
      Object.entries(filterBtns).forEach(([k, b])=>{
        if (!b) return;
        b.classList.toggle('active', k===key);
        b.setAttribute('aria-pressed', k===key ? 'true' : 'false');
      });
      filterMode = key;
      rerender();
    }
    Object.entries(filterBtns).forEach(([k,b])=> b && b.addEventListener('click', ()=> setFilter(k)));
    qEl?.addEventListener('input', rerender);

    function baseRows(){
      const filtered = applyFilters(mine, filterMode, qEl ? qEl.value : '');
      return sortRowsByUrgency(filtered, statsMapLocal);
    }
    function rerender(){ renderTable(baseRows(), statsMapLocal, ratingsMapLocal, myRatedSetLocal); }

    rerender();
  })();

  </script>
</body>
</html>
