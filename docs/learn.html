<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Learn • Path to POLISH</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --brand:#2d6cdf;
      --bg:#f7f7fb; --card:#ffffff; --text:#0c0f14; --muted:#5a6472; --border:#e6e6ef;
      --shadow:0 8px 24px rgba(0,0,0,.08);
      --radius:14px; --pad:16px; --gap:14px; --tap:48px;
      --focus:0 0 0 3px rgba(45,108,223,.35);
    }
    @media (prefers-color-scheme: dark){
      :root{ --bg:#0b0c10; --card:#121418; --text:#e7e9ee; --muted:#a7b0bf; --border:#1e2230; --shadow:0 6px 22px rgba(0,0,0,.35); }
    }
    *{ box-sizing:border-box }
    body{ font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Ubuntu,Helvetica,Arial; background:var(--bg); color:var(--text); margin:0; padding-bottom:88px; }

    /* Header */
    header{ position:sticky; top:0; z-index:10; background:var(--card); border-bottom:1px solid var(--border); }
    header .bar{ display:flex; justify-content:space-between; align-items:center; gap:12px; padding:12px 16px; }
    .hello{ font-size:clamp(18px,4.2vw,22px); margin:0 }
    .head-actions a, .head-actions button{ margin-left:8px; font-size:14px; color:var(--brand); background:none; border:1px solid var(--border); padding:8px 10px; border-radius:10px; text-decoration:none; cursor:pointer; }
    .head-actions button{ color:var(--text); }
    .wrap{ max-width:1100px; margin:0 auto; padding:14px 16px; }

    /* Tabs + search */
    .tabs{ display:flex; gap:8px; margin:6px 0 10px }
    .tab{ border:1px solid var(--border); background:var(--card); color:var(--text); padding:8px 12px; border-radius:10px; text-decoration:none; }
    .tab.active{ background:rgba(45,108,223,.12); color:var(--brand); border-color:transparent }

    .controls{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin:8px 0 10px; }
    .search{ flex:1; min-width:220px; height:42px; padding:0 12px; border:1px solid var(--border); border-radius:10px; background:var(--card); color:var(--text); }
    .seg{ display:flex; background:var(--card); border:1px solid var(--border); border-radius:10px; overflow:hidden; flex:1; min-width:320px; }
    .seg button{ padding:8px 12px; border:0; background:none; cursor:pointer; color:var(--muted); font-weight:600; flex:1 }
    .seg button.active{ background:rgba(45,108,223,.12); color:var(--brand) }

    /* Table */
    .card{ background:var(--card); border:1px solid var(--border); border-radius:var(--radius); padding:var(--pad); box-shadow:var(--shadow); }
    .table-wrap{ overflow:auto }
    table{ width:100%; border-collapse:collapse }
    th, td{ text-align:left; padding:8px 6px; border-bottom:1px solid var(--border); font-size:13px; white-space:nowrap; }
    th:first-child, td:first-child{ position:sticky; left:0; background:var(--card); }
    thead th{ font-weight:700; color:var(--muted); }
    /* tighter row layout */
    td strong{ display:block; margin-bottom:2px; font-size:14px }
    td .small{ display:block; margin-top:0; line-height:1.2; }

    .muted{ color:var(--muted) }
    .small{ font-size:11px; }
    .btn{ display:inline-flex; align-items:center; justify-content:center; height:30px; padding:0 10px; border-radius:8px; border:1px solid var(--border); background:var(--card); color:var(--text); font-weight:600; text-decoration:none; }
    .btn-primary{ background:var(--brand); color:#fff; border-color:transparent }

    /* Status pills */
    .status{ font-size:12px; padding:4px 8px; border-radius:999px; border:1px solid var(--border); color:var(--muted); display:inline-block }
    .status.green{ background:#e9f9ee; color:#197a2b; border-color:#cdebd4; }
    .status.orange{ background:#fff3e6; color:#b85b00; border-color:#ffe0c2; }
    .status.red{ background:#ffecec; color:#b42828; border-color:#ffd1d1; }
    .status.blue{ background:#eaf2ff; color:#1f5dbb; border-color:#cfe0ff; }

    /* Rating stars (text, consistent with other pages) */
    .rating{ display:inline-block; font-size:14px; letter-spacing:2px; }
    .rating .muted{ letter-spacing:normal; margin-left:6px; }

    /* Activity buttons layout (narrower gap) */
    .acts{ display:inline-flex; gap:6px; flex-wrap:wrap }

    /* Empty states */
    .empty{ text-align:center; color:var(--muted); padding:18px 0 }

    /* Bottom nav */
    nav.bottom{ position:fixed; left:0; right:0; bottom:0; background:var(--card); border-top:1px solid var(--border); display:flex; justify-content:space-around; padding:6px 8px; gap:8px; }
    nav.bottom a{ flex:1; text-align:center; padding:8px; text-decoration:none; color:var(--text); border-radius:10px; display:flex; flex-direction:column; align-items:center; gap:4px; font-size:12px }
    nav.bottom a svg{ width:20px; height:20px }
    nav.bottom a.active{ background:rgba(45,108,223,.12); color:var(--brand) }
    @supports(padding: max(0px)){ nav.bottom{ padding-bottom: max(6px, env(safe-area-inset-bottom)) } }
  </style>
</head>
<body>
  <header>
    <div class="bar">
      <h1 class="hello" id="hello">Cześć!</h1>
      <div class="head-actions">
        <a href="./profile.html" id="profileBtn">Profile</a>
        <a href="./login.html" id="loginLink">Sign In</a>
        <a href="./register.html" id="registerLink">Register</a>
        <button id="logoutBtn" style="display:none;">Logout</button>
      </div>
    </div>
  </header>

  <div class="wrap">

    <!-- Filters / search -->
    <div class="controls">
      <input id="q" class="search" placeholder="Search collections…" />
      <div class="seg" role="tablist" aria-label="Mode Filter">
        <button id="f_all"       class="active" aria-pressed="true">All</button>
        <button id="f_learn">Learn</button>
        <button id="f_speak">Speak</button>
        <button id="f_listen">Listen</button>
        <button id="f_read">Read</button>
      </div>
    </div>

    <!-- Table -->
    <div class="card">
      <div class="table-wrap">
        <table id="setsTable">
          <thead>
            <tr>
              <th style="min-width:140px;">Rating</th>
              <th style="min-width:260px;">Collection</th>
              <th style="min-width:170px;">Activity</th>
              <th style="min-width:120px;">Status</th>
            </tr>
          </thead>
          <tbody id="setsBody"></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Bottom nav -->
  <nav class="bottom">
    <a href="./index.html">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M3 10.5L12 3l9 7.5V21a1 1 0 0 1-1 1h-5v-7H9v7H4a1 1 0 0 1-1-1v-10.5Z" stroke-width="1.5"/></svg>
      <span>Home</span>
    </a>
    <a href="./learn.html" class="active" aria-current="page">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M4 6h16M4 12h16M4 18h9" stroke-width="1.5" stroke-linecap="round"/></svg>
      <span>Learn</span>
    </a>
    <a href="./manage_sets/">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><rect x="3" y="4" width="18" height="16" rx="2" ry="2" stroke-width="1.5"/><path d="M7 8h10M7 12h10M7 16h7" stroke-width="1.5" stroke-linecap="round"/></svg>
      <span>Library</span>
    </a>
    <a href="./dashboard.html">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M4 14h6V4H4v10Zm10 6h6V4h-6v16Z" stroke-width="1.5"/></svg>
      <span>Dashboard</span>
    </a>
    <a href="./groups.html">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M12 12a5 5 0 1 0-5-5 5 5 0 0 0 5 5Zm-9 9a9 9 0 0 1 18 0" stroke-width="1.5" stroke-linecap="round"/></svg>
      <span>Groups</span>
    </a>
  </nav>

  <script src="./static/js/api.js"></script>
  <script>
    // ---------- Header auth ----------
    async function wireHeader(){
      let me=null;
      try{ const r=await api.fetch('/api/me'); if(r.ok) me=await r.json(); }catch(_){}
      const hello = document.getElementById('hello');
      const loginLink   = document.getElementById('loginLink');
      const registerLink= document.getElementById('registerLink');
      const logoutBtn   = document.getElementById('logoutBtn');
      if(me){
        hello.textContent = 'Cześć' + (me.name ? ', ' + me.name : '') + '!';
        loginLink.style.display = 'none'; registerLink.style.display = 'none'; logoutBtn.style.display = 'inline-block';
      }else{
        hello.textContent = 'Cześć!';
        loginLink.style.display = 'inline-block'; registerLink.style.display = 'inline-block'; logoutBtn.style.display = 'none';
      }
      logoutBtn?.addEventListener('click', async () => {
        try{ await api.fetch('/api/logout', {method:'POST'});}catch(_){}
        localStorage.removeItem('lp_token'); location.href = './login.html';
      });
    }

    // ---------- Utilities ----------
    const PASS = 100; // perfect threshold
    function qs(k){ return new URL(location.href).searchParams.get(k); }
    function encode(name){ return encodeURIComponent(name||''); }

    // Detect set type:
    function detectTypeByName(name){
      const s = String(name||'');
      if (/\d{1,3}-\d+[Rr]$/.test(s) || /\b(read|reading|story|article)\b/i.test(s)) return 'reading';
      if (/\b(listen|listening|audio|podcast)\b/i.test(s)) return 'listening';
      return 'flashcards';
    }
    // Accepts either a set row object { name, modes? } or a plain set name (string).
    function activityModesFor(input){
      // If caller passed a row object that already has modes, use them.
      if (input && typeof input === 'object' && Array.isArray(input.modes) && input.modes.length){
        return input.modes;
      }
      // Otherwise infer from name
      const name = (typeof input === 'string') ? input : (input?.name || '');
      const t = detectTypeByName(name);
      if (t === 'reading')   return ['read'];
      if (t === 'listening') return ['listen'];
      return ['learn','speak'];
    }

    function activityModesForRow(row){
      if (Array.isArray(row?.modes) && row.modes.length) return row.modes;
      const t = detectTypeByName(row?.name);
      if (t==='reading')   return ['read'];
      if (t==='listening') return ['listen'];
      return ['learn','speak'];
    }

    function pathFor(mode, setName){
      const enc = encode(setName);
      if (mode==='read')    return './reading/'   + enc + '/';
      if (mode==='listen')  return './listening/' + enc + '/';
      if (mode==='speak')   return './practice/'  + enc + '/';
      return './flashcards/' + enc + '/'; // learn
    }

    // Text stars (consistent with other pages)
    function starsText(n){
      if (typeof n !== 'number' || isNaN(n)) n = 0;
      n = Math.max(0, Math.min(5, Math.round(n)));
      return '★'.repeat(n) + '☆'.repeat(5-n);
    }

    function timeAgoBucket(iso){
      if(!iso) return '—';
      const d = new Date(iso), now = new Date();
      const diff = (now - d) / 86400000;
      if (diff < 1) return 'today';
      if (diff < 2) return 'yesterday';
      if (diff < 7) return 'this week';
      if (diff < 30) return 'this month';
      return 'long ago';
    }

    // SRS (coarse, based on perfect dates)
    function srsStatus(perfectDates){
      const sorted = (perfectDates||[]).map(d=>new Date(d)).sort((a,b)=>b-a);
      const last = sorted[0];
      const first = sorted[sorted.length-1];
      const daysSince = last ? (Date.now() - last.getTime())/86400000 : Infinity;

      let greenDays=1;
      if(sorted.length===1) greenDays=1;
      else if(sorted.length===2) greenDays=2;
      else if(sorted.length===3) greenDays=3;
      else if(sorted.length>=4) greenDays=7;

      if (sorted.length>=5 && first && (Date.now()-first.getTime())/86400000 >= 30) {
        return {label:'Complete', cls:'green', link:false};
      }
      if (daysSince < greenDays)   return {label:'Great', cls:'green',  link:false};
      if (daysSince < greenDays+2) return {label:'Due soon', cls:'orange', link:false};
      return {label:'Repetition due', cls:'red', link:true};
    }

    function buildStatsBySet(scores){
      const map = new Map();
      for(const s of (scores||[])){
        const name = s.set_name || ''; if(!name) continue;
        const rec = map.get(name) || { best:null, trials:0, last_ts:null, perfect_dates:[] };
        const sc = Number(s.score)||0;
        const att = Number(s.attempts)||0;
        const ts = s.timestamp || null;
        rec.best = (rec.best==null) ? sc : Math.max(rec.best, sc);
        rec.trials += att || 1;
        if(ts && (!rec.last_ts || new Date(ts) > new Date(rec.last_ts))) rec.last_ts = ts;
        if(sc>=PASS && ts) rec.perfect_dates.push(ts);
        map.set(name, rec);
      }
      return map;
    }

    function applyFilters(list, filterMode, q){
      const QQ = (q||'').trim().toLowerCase();
      return list.filter(m => {
        const okQ = !QQ || (m.name.toLowerCase().includes(QQ));
        if(!okQ) return false;
        if(filterMode==='all') return true;
        const modes = activityModesFor(m.name);
        if(filterMode==='learn')  return modes.includes('learn');
        if(filterMode==='speak')  return modes.includes('speak');
        if(filterMode==='listen') return modes.includes('listen');
        if(filterMode==='read')   return modes.includes('read');
        return true;
      });
    }

    // ---- Shared render state (safe defaults) ----
    let statsMap   = new Map();   // set -> {best,trials,last_ts,perfect_dates}
    let ratingsMap = {};          // set -> {avg,count}
    let myRatedSet = new Set();   // Set<set_name>
    let modeMap    = Object.create(null); // set -> ["learn","speak"|...]
    let currentNames  = [];             // names we request ratings for (batch)

    // ---------- Data fetchers ----------
    async function fetchMe(){
      try{ const r=await api.fetch('/api/me'); return r.ok ? await r.json() : null; }catch(_){ return null; }
    }
    async function fetchMyLibrary(){
      try{
        const r = await api.fetch('/api/my/sets');
        if (r && r.status === 401) return { unauth: true, data: [] };
        if (!r || !r.ok){
          // fall back to legacy endpoint instead of returning undefined
          try{
            const r2 = await api.fetch('/api/my_sets'); // legacy
            if (r2 && r2.ok){
              const arr2 = await r2.json();
              const data2 = Array.isArray(arr2)
                ? arr2.map(x => ({ name: x.set_name || x.name || '' }))
                : [];
              return { unauth: false, data: data2 };
            }
          }catch(_){}
          return { unauth: false, data: [] };
        }
        const arr = await r.json();
        const data = Array.isArray(arr)
          ? arr.map(x => ({ name: x.set_name || x.name || '' }))
          : [];
        return { unauth: false, data };
      }catch(e){
        console.warn('fetchMyLibrary failed:', e);
        return { unauth: false, data: [] };
      }
    }

    async function fetchGlobal(){
      let gl = [];
      try{
        let r = await api.fetch('/api/global_sets');
        if(r.ok) gl = await r.json();
      }catch(_){}
      if(!Array.isArray(gl) || !gl.length){
        try{
          const r2 = await api.fetch('/api/sets/available');
          if(r2.ok){
            const arr = await r2.json();
            gl = (arr || []).map(x => ({ name: x.name, count: x.count, modes: null }));
          }
        }catch(_){}
      }
      return gl;
    }
    async function fetchMyScores(){
      const r = await api.fetch('/api/my/scores?limit=2000');
      if(!r.ok) return [];
      return await r.json();
    }
    async function fetchRatingsBatch(names){
      if(!names.length) return {};
      const r = await api.fetch('/api/sets/ratings/batch', {
        method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ sets: names })
      });
      if(!r.ok) return {};
      const arr = await r.json();
      const map = {}; (arr||[]).forEach(x => map[x.set_name] = {avg:x.avg_stars, count:x.count});
      return map;
    }
    async function fetchMyRatings(){
      const r = await api.fetch('/api/my/ratings');
      if(!r.ok) return new Set();
      const arr = await r.json();
      return new Set((arr||[]).map(x => x.set_name));
    }

    // ---------- Render ----------
    function activityButtons(name){
      const modes = activityModesFor(name);
      return `<span class="acts">${
        modes.map(m => {
          const label = m==='learn' ? 'Learn' : m==='speak' ? 'Speak' : m==='read' ? 'Read' : 'Listen';
          // Speak gets color now too
          const primary = (m==='learn' || m==='speak' || m==='read' || m==='listen') ? 'btn-primary' : '';
          return `<a class="btn ${primary}" href="${pathFor(m, name)}">${label}</a>`;
        }).join('')
      }</span>`;
    }

    function statusCell(name, stats){
      if(!stats || (!stats.trials && !stats.last_ts)){
        return `<span class="status blue">New</span>`;
      }
      const best = (typeof stats.best==='number') ? Math.round(stats.best) : null;
      if (!stats.perfect_dates || stats.perfect_dates.length === 0){
        const label = (best!=null) ? (best + '%') : 'Tried';
        return `<span class="status orange">${label}</span>`;
      }
      const srs = srsStatus(stats.perfect_dates);
      const href = pathFor(activityModesFor(name)[0], name);
      if (srs.link && srs.label === 'Repetition due'){
        return `<a class="status ${srs.cls}" href="${href}">${srs.label}</a>`;
      }
      return `<span class="status ${srs.cls}">${srs.label}</span>`;
    }

    function trFor(row, stats, rating, userHasRated){
      const ratingStars = `<span class="rating">${starsText(rating?.avg)}</span>` +
                          (typeof rating?.count==='number' ? `<span class="muted small">(${rating.count})</span>` : '');
      const addRating = userHasRated ? '' : `<div class="small"><a href="./manage_sets/">add your rating</a></div>`;
      const last = stats?.last_ts ? timeAgoBucket(stats.last_ts) : '—';
      const best = (typeof stats?.best==='number') ? ` • top ${stats.best}%` : '';
      const trials = (typeof stats?.trials==='number') ? ` • ${stats.trials} trials` : '';

      return `
        <tr>
          <td>${ratingStars}${addRating}</td>
          <td title="${row.name}">
            <strong>${row.name}</strong>
            <span class="muted small">${last}${best}${trials}</span>
          </td>
          <td>${activityButtons(row.name)}</td>
          <td>${statusCell(row.name, stats)}</td>
        </tr>
      `;
    }

    function renderTable(rows, statsMap, ratingsMap, myRatedSet){
      const body = document.getElementById('setsBody');
      body.innerHTML = rows.map(r => trFor(r, statsMap.get(r.name), ratingsMap[r.name], myRatedSet.has(r.name))).join('');
    }

  // ---------- Main ----------
  async function init(){
    await wireHeader();

    // 1) Fetch what we need
    const [libRes, globalSetsRes, scoresRes] = await Promise.all([
      fetchMyLibrary().catch(() => null),
      fetchGlobal().catch(() => []),
      fetchMyScores().catch(() => []),
    ]);

    const unauth    = !!(libRes && libRes.unauth);
    const mineRaw   = Array.isArray(libRes?.data) ? libRes.data : [];
    const globalSets= Array.isArray(globalSetsRes) ? globalSetsRes : [];
    const scores    = Array.isArray(scoresRes) ? scoresRes : [];

    // 2) Stats for table
    const statsMapLocal = buildStatsBySet(scores || []);

    // 3) Build a combined name -> modes map
    const combinedModeMap = Object.create(null);

    function modesFromType(t){
      const tt = String(t || '').toLowerCase();
      if (tt === 'reading'   || tt === 'read')      return ['read'];
      if (tt === 'listening' || tt === 'listen')    return ['listen'];
      if (tt === 'flashcards'|| tt === 'vocab' || tt === 'cards') return ['learn','speak'];
      return null;
    }
    function nameOf(x){ return (x && (x.name || x.set_name)) || ''; }

    // prefer global catalog (authoritative)
    (globalSets || []).forEach(x => {
      const n = nameOf(x);
      if (!n) return;
      if (Array.isArray(x.modes) && x.modes.length) {
        combinedModeMap[n] = x.modes;
      } else {
        const mf = modesFromType(x.type);
        if (mf) combinedModeMap[n] = mf;
      }
    });

    // fill gaps from my library (don’t override global)
    (mineRaw || []).forEach(x => {
      const n = nameOf(x);
      if (!n || combinedModeMap[n]) return;
      if (Array.isArray(x.modes) && x.modes.length) {
        combinedModeMap[n] = x.modes;
      } else {
        const mf = modesFromType(x.type);
        if (mf) combinedModeMap[n] = mf;
      }
    });

    // 4) Helpers used by filters and renderers
    function activityModesFor(name){
      const arr = combinedModeMap[name];
      if (Array.isArray(arr) && arr.length) return arr;
      return ['learn','speak']; // last-resort legacy fallback
    }
    function activityModesForRow(row){
      if (!row) return ['learn','speak'];
      if (Array.isArray(row.modes) && row.modes.length) return row.modes;
      const mf = modesFromType(row.type);
      if (mf) return mf;
      return activityModesFor(row.name || row.set_name || '');
    }
    // expose for any existing helpers
    window.activityModesFor = activityModesFor;
    window.activityModesForRow = activityModesForRow;

    // 5) Normalize "mine" rows (add modes/type for filtering)
    const mine = mineRaw.map(x => {
      const n = nameOf(x);
      const m = Array.isArray(x.modes) && x.modes.length ? x.modes : (combinedModeMap[n] || null);
      return { name: n, modes: m, type: x.type || null };
    });

    // 6) Ratings (community + mine)
    const currentNames = mine.map(r => r.name).slice(0, 400);
    const [ratingsMapLocal, myRatedSetLocal] = await Promise.all([
      fetchRatingsBatch(currentNames).catch(() => ({})),
      fetchMyRatings().catch(() => new Set()),
    ]);

    // 7) Sign-in prompt if needed
    if (unauth){
      const el = document.getElementById('emptyMine');
      if (el) el.style.display='block';
    }

    // 8) Filtering UI (All / Learn / Speak / Listen / Read + search)
    const qEl = document.getElementById('q');
    const filterBtns = {
      all:    document.getElementById('f_all'),
      learn:  document.getElementById('f_learn'),
      speak:  document.getElementById('f_speak'),
      listen: document.getElementById('f_listen'),
      read:   document.getElementById('f_read'),
    };
    let filterMode = 'all';

    function setFilter(key){
      for(const k in filterBtns){
        const b = filterBtns[k];
        if (!b) continue;
        b.classList.toggle('active', k===key);
        b.setAttribute('aria-pressed', k===key ? 'true' : 'false');
      }
      filterMode = key;
      rerender();
    }
    for(const k in filterBtns){
      const b = filterBtns[k];
      if (b) b.addEventListener('click', ()=> setFilter(k));
    }
    if (qEl) qEl.addEventListener('input', rerender);

    // 9) Data → rows → filters
    function baseRows(){
      // mine already has {name, modes, type}
      return applyFilters(mine, filterMode, qEl ? qEl.value : '');
    }

    // 10) Render
    function rerender(){
      const rows = baseRows();
      renderTable(rows, statsMapLocal, ratingsMapLocal, myRatedSetLocal);
    }

    // initial paint
    rerender();
  }

    init();
  </script>
</body>
</html>
