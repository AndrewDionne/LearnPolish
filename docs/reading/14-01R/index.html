<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Dual-host <base>: GitHub Pages vs Flask -->
  <script>
    (function () {
      var isGH = /\.github\.io$/i.test(location.hostname);
      var baseHref = isGH ? '/LearnPolish/' : '/';
      document.write('<base href="' + baseHref + '">');
    })();
  </script>

  <title>Reading ‚Ä¢ 14-01R ‚Ä¢ Path to POLISH</title>
  <link rel="stylesheet" href="static/app.css?v=5" />
  <link rel="icon" type="image/svg+xml" href="../../static/brand.svg" />

  <style>
    .wrap{ max-width:900px; margin:0 auto 92px; padding:0 16px; }
    .stack{ display:grid; gap:16px }
    .row{ display:flex; align-items:center; gap:10px; flex-wrap:wrap }
    .card{ background:var(--card); border:1px solid var(--border); border-radius:12px; padding:16px }
    .title{ font-weight:800; font-size:18px }

    .toolbar .btn{ display:inline-flex; align-items:center; gap:8px; padding:10px 14px; border-radius:10px;
      border:1px solid var(--border); background:var(--card); cursor:pointer }
    .btn-primary{ background:var(--brand); border-color:var(--brand); color:#fff }
    .btn:disabled{ opacity:.6; cursor:default }

    .passage{ font-size:1.25rem; line-height:1.9; margin-top:8px }
    .word{ display:inline-block; margin:0 1px; padding:2px 4px; border-radius:6px }
    .word.active{ outline:2px solid var(--brand); outline-offset:2px }
    .w-good{ background: rgba(16,180,0,.14); }
    .w-mid { background: rgba(255,165,0,.16); }
    .w-bad { background: rgba(255,0,0,.14); }

    .meta{ color:var(--muted); font-size:.95rem }
    .stats{ margin-top:10px; border:1px solid var(--border); border-radius:10px; padding:10px; background:var(--card) }

    select{ padding:8px 10px; border-radius:10px; border:1px solid var(--border); background:var(--card) }

    /* Debug overlay (toggle via ?debug=1) */
    #dbg{ display:none; position:fixed; bottom:8px; left:8px; right:8px; max-height:44vh; overflow:auto;
      background:#000; color:#0f0; padding:8px 10px; border-radius:10px; font-family:ui-monospace, Menlo, monospace;
      font-size:12px; white-space:pre-wrap; z-index:9999 }
  </style>
</head>

<body
  data-header="Path to Polish"
  data-note-lead="Reading"
  data-note-tail="14-01R"
  style="--logo-size:40px; --banner-size:24px; --banner-size-lg:30px">

  <!-- Header -->
  <header class="topbar no-nav">
    <div class="row container">
      <div class="header-left">
        <a class="brand" href="index.html" aria-label="Path to Polish ‚Äî Home">
          <svg class="brand-mark" aria-hidden="true" focusable="false">
            <use href="static/brand.svg#ptp-mark"></use>
          </svg>
          <span id="headerBanner" class="header-banner"></span>
        </a>
      </div>
      <nav class="head-actions">
        <a href="profile.html"  id="profileBtn">Profile</a>
        <a href="login.html"    id="loginLink">Sign In</a>
        <a href="register.html" id="registerLink">Register</a>
        <button id="logoutBtn" style="display:none;">Logout</button>
      </nav>
    </div>
  </header>

  <main class="wrap stack">
    <section class="card">
      <div class="row toolbar">
        <div class="row">
          <label for="passageSelect"><strong>Passage:</strong></label>
          <select id="passageSelect"></select>
        </div>
        <button id="btnStart" class="btn btn-primary">üé§ Start Reading</button>
        <button id="btnStop" class="btn" disabled>‚èπ Stop</button>
        <button id="btnListen" class="btn">üîä Listen (Polish)</button>
        <button id="btnReplay" class="btn" disabled>üéß Replay Me</button>
        <button id="btnToggleEN" class="btn">üá¨üáß Show Translation</button>
        <button id="btnOffline" class="btn">‚¨áÔ∏è Offline</button>
        <button id="btnOfflineRm" class="btn" style="display:none;">üóë Remove</button>
        <button id="btnFinish" class="btn">‚úÖ Finish</button>

      </div>

      <div id="title" class="meta"></div>
      <div id="passage" class="passage"></div>
      <div id="translation" class="meta" style="display:none; margin-top:8px"></div>

      <div id="stats" class="stats">Ready.</div>
      <div id="status" class="meta" style="margin-top:8px"></div>
      <div id="offlineStatus" class="meta" style="margin-top:8px"></div>

      <!-- Hidden audio tags -->
      <audio id="ttsAudio"></audio>
      <audio id="replayAudio"></audio>
    </section>
  </main>

  <div id="dbg"></div>

  <!-- Bottom nav -->
  <nav class="bottom" aria-label="Primary">
    <a href="index.html">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M3 10.5L12 3l9 7.5V21a1 1 0 0 1-1 1h-5v-7H9v7H4a1 1 0 0 1-1-1v-10.5Z" stroke-width="1.5"/></svg>
      <span>Home</span>
    </a>
    <a href="learn.html" class="active" aria-current="page">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M4 6h16M4 12h16M4 18h9" stroke-width="1.5" stroke-linecap="round"/></svg>
      <span>Learn</span>
    </a>
    <a href="manage_sets/index.html">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><rect x="3" y="4" width="18" height="16" rx="2" ry="2" stroke-width="1.5"/><path d="M7 8h10M7 12h10M7 16h7" stroke-width="1.5" stroke-linecap="round"/></svg>
      <span>Library</span>
    </a>
    <a href="dashboard.html">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M4 14h6V4H4v10Zm10 6h6V4h-6v16Z" stroke-width="1.5"/></svg>
      <span>Dashboard</span>
    </a>
    <a href="groups.html">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M12 12a5 5 0 1 0-5-5 5 5 0 0 0 5 5Zm-9 9a9 9 0 0 1 18 0" stroke-width="1.5" stroke-linecap="round"/></svg>
      <span>Groups</span>
    </a>
  </nav>

  <!-- Scripts -->
  <script src="static/js/app-config.js"></script>
  <script src="static/js/api.js"></script>
  <script src="static/js/page-chrome.js" defer></script>
  <script src="static/js/audio-paths.js"></script>
  <script src="static/js/results.js"></script>
  <script src="https://aka.ms/csspeech/jsbrowserpackageraw"></script>

  <script>
    const passages = [{"polish": "Ala ma kota.", "english": "Ala has a cat.", "title": "Story 1"}, {"polish": "Dzisiaj idziemy do parku.", "english": "Today we are going to the park.", "title": "Spacer"}];
    const setName  = "14-01R";
    const SpeechSDK = window.SpeechSDK;

    const DEBUG = new URL(location.href).searchParams.get('debug') === '1';
    const dbgEl = document.getElementById('dbg');
    if (DEBUG) dbgEl.style.display = 'block';
    function dbg(...a){ if (!DEBUG) return; const d=document.createElement('div'); d.textContent=a.map(x=>typeof x==='string'?x:JSON.stringify(x)).join(' '); dbgEl.appendChild(d); dbgEl.scrollTop=dbgEl.scrollHeight; }

    let currentIndex = 0;
    let recognizer = null;
    let recording = null; // MediaRecorder
    let chunks = [];
    let replayUrl = null;
    let startTime = 0;
    let wordsSpans = [];
    let wordsMeta  = []; // { text, idx, score }
    let r2Manifest = null;

    // ----- Helpers -----
    function byId(id){ return document.getElementById(id); }
    function _norm(s){
      return (s||"").normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().replace(/[-‚Äì‚Äî]/g,'');
    }

    async function prewarmMic(){
      try {
        const m = await navigator.mediaDevices.getUserMedia({ audio:true });
        m.getTracks().forEach(t=>t.stop());
      } catch(_){
      }
    }

    function populateSelect(){
      const sel = byId('passageSelect'); sel.innerHTML = '';
      passages.forEach((p,i)=>{
        const o = document.createElement('option');
        o.value = i; o.textContent = p.title || ('Passage ' + (i+1));
        sel.appendChild(o);
      });
      sel.value = '0';
    }

    function renderPassage(i){
      const p = passages[i] || {};
      byId('title').textContent = p.title || '';
      byId('translation').textContent = p.english || '';
      const cont = byId('passage'); cont.innerHTML = '';
      wordsSpans = []; wordsMeta = [];

      const tokens = String(p.polish||'')
        .replace(/[.,!?;:()¬´¬ª‚Äû‚Äù"‚Äô'\[\]{}]/g, ' ')
        .split(/\s+/).filter(Boolean);

      tokens.forEach((w, idx)=>{
        const span = document.createElement('span');
        span.className = 'word'; span.dataset.idx = String(idx);
        span.textContent = w; cont.appendChild(span);
        wordsSpans.push(span); wordsMeta.push({ text:w, idx, score:null });
        cont.appendChild(document.createTextNode(' '));
      });
      highlightWord(0);
      byId('stats').textContent = 'Ready.';
      byId('status').textContent = '';
      byId('btnReplay').disabled = true;
    }

    function colorByScore(s){
      if (s==null || isNaN(s)) return '';
      if (s >= 80) return 'w-good';
      if (s >= 60) return 'w-mid';
      return 'w-bad';
    }

    function highlightWord(idx){
      wordsSpans.forEach(s=>s.classList.remove('active'));
      if (idx>=0 && idx<wordsSpans.length) wordsSpans[idx].classList.add('active');
    }

    function computeWPM(ms, words){
      if (ms<=0) return 0; return Math.round((words/(ms/1000))*60);
    }

    function updateStats(final=false){
      const done = wordsMeta.filter(w=>typeof w.score==='number');
      const avg = done.length ? (done.reduce((a,b)=>a+b.score,0)/done.length) : 0;
      const elapsed = Date.now()-startTime;
      const wpm = computeWPM(elapsed, done.length);
      const status = final ? 'Finished' : 'Listening‚Ä¶';
      byId('stats').innerHTML = `
        <div><strong>Status:</strong> ${status}</div>
        <div><strong>Pronunciation (avg):</strong> ${avg.toFixed(1)}%</div>
        <div><strong>Words recognized:</strong> ${done.length} / ${wordsMeta.length}</div>
        <div><strong>WPM:</strong> ${wpm}</div>
      `;
    }

    // ----- Token cache -----
    async function fetchToken(){
      const c = window.__speechTok;
      if (c && c.exp > Date.now()) return c;
      const tok = await api.get('/api/speech_token', { noAuth:true });
      const token  = tok && (tok.token || tok.access_token);
      const region = tok && (tok.region || tok.location || tok.regionName);
      if (!token || !region) return { token:null, region:null, exp:0 };
      const ttl = Math.max(60_000, ((tok.expires_in ? tok.expires_in : 540)*1000) - 30_000);
      const out = { token, region, exp: Date.now()+ttl };
      window.__speechTok = out;
      return out;
    }

    async function speechConfig(){
      if (!window.SpeechSDK) throw new Error('sdk_not_loaded');
      const t = await fetchToken();
      if (!t.token || !t.region) throw new Error('no_token');
      const cfg = SpeechSDK.SpeechConfig.fromAuthorizationToken(t.token, t.region);
      cfg.speechRecognitionLanguage = 'pl-PL';
      cfg.outputFormat = SpeechSDK.OutputFormat.Detailed;
      cfg.setProperty(SpeechSDK.PropertyId.SpeechServiceResponse_RequestDetailedResultTrueFalse, 'true');
      cfg.setProperty(SpeechSDK.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, 'true');
      cfg.setProperty(SpeechSDK.PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs, '2000');
      cfg.setProperty(SpeechSDK.PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs, '800');
      return cfg;
    }

    async function makeRecognizer(referenceText){
      const cfg = await speechConfig();
      const audioCfg = SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();
      const rec = new SpeechSDK.SpeechRecognizer(cfg, audioCfg);
      if (referenceText){
        const pa = new SpeechSDK.PronunciationAssessmentConfig(
          referenceText,
          SpeechSDK.PronunciationAssessmentGradingSystem.HundredMark,
          SpeechSDK.PronunciationAssessmentGranularity.Word,
          true
        );
        pa.applyTo(rec);
        try { SpeechSDK.PhraseListGrammar.fromRecognizer(rec)?.add(referenceText); } catch(_){
        }
      }
      return rec;
    }

    // ----- Aligning & scoring -----
    function attachHandlers(rec, reference){
      const wordsNorm = wordsMeta.map(w=>_norm(w.text));
      let nextPtr = 0; const LOOKAHEAD = 4;

      function applyFromJson(j){
        const nb = j?.NBest?.[0];
        const words = nb?.Words || [];
        if (!words.length) return;
        for (const w of words){
          const wt = _norm(w.Word || w.word || w.Display || '');
          const sc = Math.round(w?.PronunciationAssessment?.AccuracyScore ?? 0);
          if (!wt) continue;
          let match=-1;
          for (let k=0;k<LOOKAHEAD && (nextPtr+k)<wordsNorm.length;k++) {
            if (wordsNorm[nextPtr+k] === wt) { match = nextPtr+k; break; }
          }
          if (match>=0){
            while(nextPtr<match){
              if (wordsMeta[nextPtr].score==null) wordsMeta[nextPtr].score = 0;
              wordsSpans[nextPtr].classList.remove('w-good','w-mid','w-bad');
              wordsSpans[nextPtr].classList.add(colorByScore(0));
              nextPtr++;
            }
            wordsMeta[match].score = sc;
            wordsSpans[match].className = 'word ' + colorByScore(sc);
            nextPtr = match+1;
          }
        }
        highlightWord(nextPtr);
        updateStats();
      }

      function parseAny(e){
        try {
          const rawPA  = e?.result?.privPronunciationAssessmentJson || e?.privPronunciationAssessmentJson;
          const rawSTT = e?.result?.properties?.getProperty(SpeechSDK.PropertyId.SpeechServiceResponse_JsonResult);
          const raw = rawPA || rawSTT; if (!raw) return null;
          const j = JSON.parse(raw); if (DEBUG) dbg('json', j);
          return j;
        } catch(_){
          return null;
        }
      }

      startTime = Date.now();
      rec.recognizing = (s,e)=>{ byId('status').textContent='üéô Listening‚Ä¶'; const j=parseAny(e); if (j) applyFromJson(j); };
      rec.recognized  = (s,e)=>{ const j=parseAny(e); if (j) applyFromJson(j); };
      rec.canceled    = ()=>{ byId('status').textContent='‚ö†Ô∏è Canceled'; };
      rec.sessionStarted = ()=>{ byId('status').textContent='üéô Session started'; };
      rec.sessionStopped = ()=>{ byId('status').textContent='üõë Session stopped'; updateStats(true); };
    }

    // ----- Optional local recording (for replay) -----
    function startLocalRecord(){
      chunks = [];
      navigator.mediaDevices.getUserMedia({ audio:true }).then(stream=>{
        recording = new MediaRecorder(stream);
        recording.ondataavailable = e=>{ if (e.data.size>0) chunks.push(e.data); };
        recording.start();
      }).catch(()=>{});
    }
    function stopLocalRecord(){
      return new Promise(resolve=>{
        if (!recording) return resolve(null);
        recording.onstop = ()=>{
          try { if (replayUrl) URL.revokeObjectURL(replayUrl); } catch(_){
          }
          const blob = new Blob(chunks, { type:'audio/webm' });
          replayUrl = URL.createObjectURL(blob);
          resolve(replayUrl);
        };
        try { recording.stop(); } catch(_){
          resolve(null);
        }
      });
    }

    // ----- Actions -----
    async function startReading(){
      const p = passages[currentIndex] || {};
      const reference = String(p.polish||'');
      if (!reference.trim()) return;
      wordsMeta.forEach((w,i)=>{ w.score=null; wordsSpans[i].className='word'; });
      highlightWord(0);
      byId('btnStart').disabled = true;
      byId('btnStop').disabled = false;
      byId('btnReplay').disabled = true;
      byId('status').textContent = 'üéô Preparing‚Ä¶';

      await prewarmMic();
      await fetchToken().catch(()=>{});
      await new Promise(r=>setTimeout(r, 200));

      recognizer = await makeRecognizer(reference);
      attachHandlers(recognizer, reference);

      await new Promise((resolve,reject)=>{
        try { recognizer.startContinuousRecognitionAsync(resolve, reject); }
        catch(e){ reject(e); }
      }).catch(e=>{ dbg('start error', e?.message||e); });
      startLocalRecord();
    }

    async function stopReading(){
      byId('btnStop').disabled = true;
      try {
        if (recognizer){
          await new Promise(res=>{
            try{ recognizer.stopContinuousRecognitionAsync(()=>res(), ()=>res()); }
            catch(_e){ res(); }
          });
        }
      } finally {
        const url = await stopLocalRecord();
        if (url){
          const a = byId('replayAudio'); a.src = url; a.load();
          byId('btnReplay').disabled = false;
        }
        byId('btnStart').disabled = false;
        byId('status').textContent = 'üõë Stopped';
        updateStats(true);
      }
    }

    function listenPolish(){
      const a = byId('ttsAudio');
      const p = passages[currentIndex] || {};
      const direct = p.audio_url || p.audio;
      let src = '';
      if (direct && /^https?:\/\//i.test(direct)) src = direct;
      else if (window.AudioPaths) src = AudioPaths.readingPath(setName, currentIndex, r2Manifest);
      else src = `../../static/${encodeURIComponent(setName)}/reading/${encodeURIComponent(currentIndex)}.mp3`;
      a.onerror = ()=> byId('status').textContent='üîá Audio not found for this passage.';
      a.src = src; a.load();
      a.play().catch(()=> byId('status').textContent='üîá Unable to play audio.');
    }

    function replayMe(){
      const a = byId('replayAudio'); if (!a.src) return;
      a.currentTime = 0; a.play().catch(()=>{});
    }

    function toggleEN(){
      const el = byId('translation');
      const vis = el.style.display !== 'none';
      el.style.display = vis ? 'none' : 'block';
      byId('btnToggleEN').textContent = vis ? 'üá¨üáß Show Translation' : 'üá¨üáß Hide Translation';
    }

    // ----- Offline SW -----
    function readingAudioUrls(){
      const urls = [];
      for (let i=0;i<passages.length;i++){
        if (window.AudioPaths) urls.push(AudioPaths.readingPath(setName, i, r2Manifest));
        else urls.push(`../../static/${encodeURIComponent(setName)}/reading/${encodeURIComponent(i)}.mp3`);
      }
      return Array.from(new Set(urls));
    }
    async function ensureSW(){
      if (!('serviceWorker' in navigator)) return null;
      try {
        const reg = await navigator.serviceWorker.register('./sw.js', { scope:'./' });
        await navigator.serviceWorker.ready;
        return reg;
      } catch(e){ dbg('sw fail', e?.message||e); return null; }
    }

    // ----- Wire UI -----
    function wire(){
      byId('passageSelect').addEventListener('change', e=>{ currentIndex = parseInt(e.target.value,10)||0; renderPassage(currentIndex); });
      byId('btnStart').addEventListener('click', startReading);
      byId('btnStop').addEventListener('click', stopReading);
      byId('btnListen').addEventListener('click', listenPolish);
      byId('btnReplay').addEventListener('click', replayMe);
      byId('btnToggleEN').addEventListener('click', toggleEN);
      byId('btnFinish').addEventListener("click", finishSession);

      // Offline handlers
      byId('btnOffline').addEventListener('click', async ()=>{
        const reg = await ensureSW(); const s = byId('offlineStatus');
        if (!reg || !reg.active) return s.textContent='‚ùå Offline not available.';
        s.textContent = '‚¨áÔ∏è Downloading‚Ä¶';
        reg.active.postMessage({ type:'CACHE_SET', cache:`reading-14-01R`, urls: readingAudioUrls() });
      });
      byId('btnOfflineRm').addEventListener('click', async ()=>{
        const reg = await ensureSW(); if (!reg || !reg.active) return;
        reg.active.postMessage({ type:'UNCACHE_SET', cache:`reading-14-01R` });
      });
      navigator.serviceWorker?.addEventListener('message', ev=>{
        const d = ev.data || {}; const s = byId('offlineStatus');
        if (d.type==='CACHE_PROGRESS') s.textContent=`‚¨áÔ∏è ${d.done} / ${d.total} files cached‚Ä¶`;
        else if (d.type==='CACHE_DONE') { s.textContent='‚úÖ Available offline'; byId('btnOfflineRm').style.display='inline-flex'; }
        else if (d.type==='UNCACHE_DONE') { s.textContent='üóë Removed offline copy'; byId('btnOfflineRm').style.display='none'; }
        else if (d.type==='CACHE_ERROR') s.textContent='‚ùå Offline failed';
      });

      // Page chrome auth state
      (async () => {
        try {
          const r = await api.fetch('/api/me');
          if (r.ok) {
            byId('loginLink').style.display='none';
            byId('registerLink').style.display='none';
            byId('logoutBtn').style.display='inline-flex';
          }
        } catch(_){
        }
        byId('logoutBtn')?.addEventListener('click', async ()=>{
          try { await api.fetch('/api/logout', {method:'POST'}); } catch(_){
          }
          api.clearToken(); location.href='login.html';
        });
      })();
    }

    // ----- Lifecycle -----
    (async function init(){
      try { if (window.AudioPaths) r2Manifest = await AudioPaths.fetchManifest(setName); } catch(_){
        r2Manifest = null;
      }
      populateSelect();
      renderPassage(0);
      wire();
      // Prefetch token to reduce latency
      fetchToken().catch(()=>{});
    })();

    window.addEventListener('beforeunload', ()=>{
      try { recognizer && recognizer.stopContinuousRecognitionAsync(); } catch(_){
      }
      try { replayUrl && URL.revokeObjectURL(replayUrl); } catch(_){
      }
    });
    document.addEventListener('visibilitychange', ()=>{
      if (document.hidden) try { recognizer && recognizer.stopContinuousRecognitionAsync(); } catch(_){
      }
    });

    function computeAvgScore(){
      const done = wordsMeta.filter(w => typeof w.score === "number");
      if (!done.length) return 0;
      return done.reduce((a,b)=>a+b.score,0) / done.length;
    }

    async function finishSession(){
      const avg = Math.max(0, Math.min(100, Math.round(computeAvgScore())));
      const elapsed = Date.now() - startTime;
      const wpm = computeWPM(elapsed, wordsMeta.filter(w => typeof w.score === "number").length);
      const details = {
        mode: 'reading',
        set: setName,
        passage_index: currentIndex,
        avg_accuracy: avg,
        wpm,
        words: wordsMeta
      };
      try{
        await Results.submit({ set: setName, mode: 'reading', score: avg, details });
      }finally{
        Results.goSummary({ set: setName, mode: 'reading', score: avg });
      }
    }

  </script>
</body>
</html>
