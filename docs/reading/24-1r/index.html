<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Reading ¬∑ 24-1r</title>
<link rel="preconnect" href="https://aka.ms">
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif; margin: 24px; max-width: 900px; }
  .toolbar { display:flex; gap:8px; flex-wrap: wrap; align-items:center; margin-bottom: 12px; }
  button { padding:8px 12px; border-radius: 10px; border:0; background:#007bff; color:#fff; cursor:pointer; }
  button.secondary { background:#6c757d; }
  .passage { font-size: 1.35rem; line-height: 1.8; margin: 16px 0; }
  .word { padding: 2px 4px; border-radius: 6px; margin: 0 1px; display:inline-block; }
  .word.active { outline: 2px solid #007bff; }
  .w-good { background: rgba(0,180,0,.12); }
  .w-mid  { background: rgba(255,165,0,.15); }
  .w-bad  { background: rgba(255,0,0,.12); }
  .meta { color:#666; font-size: .9rem; margin-top: -4px; }
  .stats { margin-top: 12px; padding: 10px; border: 1px solid #eee; border-radius: 10px; background:#fafafa; }
  .translation { margin-top: 12px; color:#333; display:none; }
  .translation.visible { display:block; }
  .row { display:flex; align-items:center; gap:8px; flex-wrap: wrap; }
  select { padding:6px; border-radius:8px; }
  audio { display:none; }
  a.home { position:absolute; right:16px; top:16px; text-decoration:none; background:#007bff; color:#fff; padding:6px 10px; border-radius:8px; }
</style>
<script src="https://aka.ms/csspeech/jsbrowserpackageraw"></script>
</head>
<body>
  <a class="home" href="#" onclick="goHome(); return false;">üè† Home</a>

  <h1>Reading ¬∑ 24-1r</h1>

  <div class="toolbar">
    <div class="row">
      <label for="passageSelect"><strong>Passage:</strong></label>
      <select id="passageSelect"></select>
    </div>
    <button id="btnStart">üé§ Start Reading</button>
    <button id="btnStop" class="secondary">‚èπ Stop</button>
    <button id="btnListen" class="secondary">üîä Listen (Polish)</button>
    <button id="btnReplay" class="secondary">üéß Replay Me</button>
    <button id="btnToggleEN" class="secondary">üá¨üáß Show Translation</button>
  </div>

  <div id="title" class="meta"></div>
  <div id="passage" class="passage"></div>
  <div id="translation" class="translation"></div>
  <div id="stats" class="stats">Ready.</div>
  <div id="status" class="meta"></div>

  <!-- Hidden audios -->
  <audio id="ttsAudio"></audio>
  <audio id="replayAudio"></audio>

<script>
const passages = [{"title": "Story 1", "polish": "Ala ma kota.", "english": "Ala has a cat."}, {"title": "Spacer", "polish": "Dzisiaj idziemy do parku.", "english": "Today we are going to the park."}];
const setName = "24-1r";
const SpeechSDK = window.SpeechSDK;

let currentIndex = 0;
let recognizer = null;
let mediaRecorder = null;
let recordedChunks = [];
let startTime = 0;
let wordsSpans = [];
let wordsMeta = []; // { text, idx, score }

// ---------- Helpers ----------
function byId(id) { return document.getElementById(id); }

function repoBase() {
  if (window.location.hostname === "andrewdionne.github.io") {
    const parts = window.location.pathname.split("/").filter(Boolean);
    const repo = parts.length ? parts[0] : "LearnPolish";
    return "/" + repo;
  }
  return "";
}

function apiBase() {
  return (window.location.hostname === "andrewdionne.github.io") ? "https://flashcards-5c95.onrender.com" : "";
}

function cardAudioPathReading(index) {
  // GH Pages: /<repo>/static/<setName>/reading/<index>.mp3
  // Local dev: /custom_static/<setName>/reading/<index>.mp3
  if (window.location.hostname === "andrewdionne.github.io") {
    return repoBase() + `/static/${setName}/reading/${index}.mp3`;
  } else {
    return `/custom_static/${setName}/reading/${index}.mp3`;
  }
}

function populateSelect() {
  const sel = byId("passageSelect");
  sel.innerHTML = "";
  passages.forEach((p, i) => {
    const opt = document.createElement("option");
    opt.value = i;
    opt.textContent = p.title || ("Passage " + (i+1));
    sel.appendChild(opt);
  });
  sel.value = "0";
}

function renderPassage(i) {
  const p = passages[i] || {};
  byId("title").textContent = p.title || "";
  byId("translation").textContent = p.english || "";
  const container = byId("passage");
  container.innerHTML = "";
  wordsSpans = [];
  wordsMeta = [];

  const tokens = (p.polish || "").split(/\s+/).filter(Boolean);
  tokens.forEach((w, idx) => {
    const span = document.createElement("span");
    span.className = "word";
    span.dataset.idx = String(idx);
    span.textContent = w;
    container.appendChild(span);
    wordsSpans.push(span);
    wordsMeta.push({ text: w, idx, score: null });
    container.appendChild(document.createTextNode(" "));
  });
  byId("stats").textContent = "Ready.";
  byId("status").textContent = "";
}

function colorByScore(s) {
  if (s === null || isNaN(s)) return "";
  if (s >= 80) return "w-good";
  if (s >= 60) return "w-mid";
  return "w-bad";
}

function highlightWord(idx, cls="active") {
  wordsSpans.forEach(s => s.classList.remove("active"));
  if (idx >=0 && idx < wordsSpans.length) {
    wordsSpans[idx].classList.add(cls);
    wordsSpans[idx].scrollIntoView({ block:"center", inline:"nearest", behavior:"smooth" });
  }
}

function computeWPM(elapsedMs, wordsCount) {
  if (elapsedMs <= 0) return 0;
  return Math.round((wordsCount / (elapsedMs/1000)) * 60);
}

function updateStats(final=false) {
  const done = wordsMeta.filter(w => typeof w.score === "number");
  const avg = done.length ? (done.reduce((a,b)=>a+b.score,0) / done.length) : 0;
  const elapsed = Date.now() - startTime;
  const wpm = computeWPM(elapsed, done.length);
  const status = final ? "Finished" : "Listening‚Ä¶";
  byId("stats").innerHTML = `
    <div><strong>Status:</strong> ${status}</div>
    <div><strong>Pronunciation (avg of scored words):</strong> ${avg.toFixed(1)}%</div>
    <div><strong>Words recognized:</strong> ${done.length} / ${wordsMeta.length}</div>
    <div><strong>WPM:</strong> ${wpm}</div>
  `;
}

// ---------- Azure token & TTS ----------
async function fetchToken() {
  const res = await fetch(`${apiBase()}/api/token`);
  if (!res.ok) throw new Error("token http " + res.status);
  return await res.json();
}

async function speechConfig() {
  const tk = await fetchToken();
  const cfg = SpeechSDK.SpeechConfig.fromAuthorizationToken(tk.token, tk.region);
  cfg.speechRecognitionLanguage = "pl-PL";
  // More forgiving silence windows for reading passages
  cfg.setProperty(SpeechSDK.PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs, "5000");
  cfg.setProperty(SpeechSDK.PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs, "1200");
  return cfg;
}

async function speakPolish(text) {
  try {
    const tk = await fetchToken();
    const cfg = SpeechSDK.SpeechConfig.fromAuthorizationToken(tk.token, tk.region);
    cfg.speechSynthesisLanguage = "pl-PL";
    const synth = new SpeechSDK.SpeechSynthesizer(cfg);
    const a = byId("ttsAudio");
    return new Promise((resolve) => {
      synth.speakTextAsync(text || "", result => {
        try {
          if (result && result.audioData) {
            const blob = new Blob([result.audioData], {type: "audio/wav"});
            const url = URL.createObjectURL(blob);
            a.src = url; a.load();
            a.onended = () => resolve();
            a.play().catch(() => resolve());
          } else {
            resolve();
          }
        } finally {
          synth.close();
        }
      }, err => {
        console.warn("TTS error:", err);
        try { synth.close(); } catch(_){}
        resolve();
      });
    });
  } catch (e) {
    console.warn("TTS fetch/config error:", e);
  }
}

// ---------- Recognition wiring ----------
async function setupRecognizer(referenceText) {
  const cfg = await speechConfig();
  const audioConfig = SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();
  recognizer = new SpeechSDK.SpeechRecognizer(cfg, audioConfig);

  const pa = new SpeechSDK.PronunciationAssessmentConfig(
    referenceText,
    SpeechSDK.PronunciationAssessmentGradingSystem.HundredMark,
    SpeechSDK.PronunciationAssessmentGranularity.Word,
    true  // miscue
  );
  pa.applyTo(recognizer);
}

function startRecordingMyAudio() {
  recordedChunks = [];
  navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
    mediaRecorder = new MediaRecorder(stream);
    mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
    mediaRecorder.start();
  }).catch(() => {});
}

function stopRecordingMyAudio() {
  return new Promise(resolve => {
    if (!mediaRecorder) return resolve(null);
    mediaRecorder.onstop = () => {
      const blob = new Blob(recordedChunks, { type: "audio/webm" });
      const url = URL.createObjectURL(blob);
      resolve(url);
    };
    try { mediaRecorder.stop(); } catch(e) { resolve(null); }
  });
}

function attachRecognitionHandlers() {
  recognizer.recognized = (s, e) => {
    if (!e || !e.result || !e.result.json) return;
    try {
      const j = JSON.parse(e.result.json);
      const nbest = (j.NBest && j.NBest[0]) ? j.NBest[0] : null;
      if (!nbest) return;

      const words = nbest.Words || [];
      words.forEach(w => {
        const text = w.Word;
        const score = (w.PronunciationAssessment && w.PronunciationAssessment.AccuracyScore) || null;

        // Match next unscored token (case-insensitive; strip punctuation)
        const norm = (t) => (t||"").toLowerCase().replace(/[.,!?;:()"]/g, "");
        const matchIdx = wordsMeta.findIndex(m => m.score === null && norm(m.text) === norm(text));
        if (matchIdx !== -1) {
          wordsMeta[matchIdx].score = score;
          const span = wordsSpans[matchIdx];
          span.classList.remove("w-good","w-mid","w-bad");
          const cls = colorByScore(score);
          if (cls) span.classList.add(cls);
          highlightWord(matchIdx);
        }
      });

      updateStats(false);
    } catch(err) {
      console.warn("recognize parse error", err);
    }
  };

  recognizer.sessionStarted = () => {
    byId("status").textContent = "Session started. Speak now‚Ä¶";
    startTime = Date.now();
    updateStats(false);
  };

  recognizer.sessionStopped = async () => {
    byId("status").textContent = "Session stopped.";
    const url = await stopRecordingMyAudio();
    if (url) {
      const a = byId("replayAudio");
      a.src = url; a.load();
    }
    updateStats(true);
  };

  recognizer.canceled = () => {
    byId("status").textContent = "Canceled.";
  };
}

async function startReading() {
  const p = passages[currentIndex] || {};
  if (!SpeechSDK) {
    byId("status").textContent = "‚ùå Azure SDK not loaded.";
    return;
  }
  await setupRecognizer(p.polish || "");
  attachRecognitionHandlers();
  await new Promise(r => setTimeout(r, 300));
  byId("status").textContent = "üé§ Speak now‚Ä¶";
  startRecordingMyAudio();
  recognizer.startContinuousRecognitionAsync();
}

function stopReading() {
  try {
    if (recognizer) recognizer.stopContinuousRecognitionAsync();
  } catch(_){}
}

function listenPolish() {
  // Try pre-rendered file first; fall back to Azure TTS if not found/blocked
  const a = byId("ttsAudio");
  const src = cardAudioPathReading(currentIndex);
  a.src = src; a.load();
  const tryTTS = () => {
    const p = passages[currentIndex] || {};
    speakPolish(p.polish || "");
  };
  a.onerror = tryTTS;
  a.play().catch(tryTTS);
}

function replayMe() {
  byId("replayAudio").play().catch(()=>{});
}

function toggleEN() {
  const el = byId("translation");
  el.classList.toggle("visible");
  byId("btnToggleEN").textContent = el.classList.contains("visible") ? "üá¨üáß Hide Translation" : "üá¨üáß Show Translation";
}

// ---------- UI / lifecycle ----------
function wireUI() {
  byId("passageSelect").addEventListener("change", (e) => {
    currentIndex = parseInt(e.target.value, 10) || 0;
    renderPassage(currentIndex);
  });
  byId("btnStart").addEventListener("click", startReading);
  byId("btnStop").addEventListener("click", stopReading);
  byId("btnListen").addEventListener("click", listenPolish);
  byId("btnReplay").addEventListener("click", replayMe);
  byId("btnToggleEN").addEventListener("click", toggleEN);

  // Clean up mic/recognizer if user navigates away
  window.addEventListener("beforeunload", () => {
    try { if (recognizer) recognizer.stopContinuousRecognitionAsync(); } catch(_){}
  });
  document.addEventListener("visibilitychange", () => {
    if (document.hidden) {
      try { if (recognizer) recognizer.stopContinuousRecognitionAsync(); } catch(_){}
    }
  });
}

function goHome() {
  if (window.location.hostname === "andrewdionne.github.io") {
    window.location.href = repoBase() + "/";
  } else {
    window.location.href = "/";
  }
}

(function init() {
  // SDK hint
  if (!SpeechSDK) {
    byId("status").textContent = "‚ö†Ô∏è Azure SDK not loaded (check network).";
  }
  // Build UI
  populateSelect();
  renderPassage(0);
  wireUI();
})();
</script>
</body>
</html>
